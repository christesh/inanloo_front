/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { div, mod } from './ArithmeticUtils';
import { InvalidJalaliDateError } from './InvalidJalaliDate.error';
import * as i0 from "@angular/core";
/**
 * Methods of this Service doing validation stuff on a Jalali date. You can use this Service using DI in all around of your app for
 * validating Jalali dates without needing to convert them to the Georgian Date.
 */
export class JalaliDateValidatorService {
    constructor() { }
    /**
     * Returns number of days in a given month counting from 1.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth number of month from 0 for Farvardin to 11 for Esfand.
     * @return {?}
     */
    jMonthLength(jYear, jMonth) {
        if (jMonth < 6) {
            return 31;
        }
        if (jMonth < 11 || this.isJYearLeap(jYear)) {
            return 30;
        }
        return 29;
    }
    /**
     * Calculates the number of the leap years in jalali Calendar.
     * @param {?} targetJYear should be full year like: 1397 and should be between -61 to 3177.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L71}
     * @return {?}
     */
    numOfJLeapYears(targetJYear) {
        // Jalali years starting the 33-year rule.
        /** @type {?} */
        const breaks = [
            -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210,
            1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178,
        ];
        /** @type {?} */
        const breaksLength = breaks.length;
        /** @type {?} */
        let jp = breaks[0];
        /** @type {?} */
        let jump;
        /** @type {?} */
        let leapJ = -14;
        if (!this.isValidJYear(targetJYear)) {
            throw new InvalidJalaliDateError();
        }
        // Find the limiting years for the Jalali year jy.
        for (let i = 1; i < breaksLength; i += 1) {
            /** @type {?} */
            const jm = breaks[i];
            jump = jm - jp;
            if (targetJYear < jm) {
                break;
            }
            leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
            jp = jm;
        }
        /** @type {?} */
        const n = targetJYear - jp;
        // Find the number of leap years from AD 621 to the beginning
        // of the current Jalali year in the Persian Calendar.
        leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
        if (mod(jump, 33) === 4 && jump - n === 4) {
            leapJ += 1;
        }
        return leapJ;
    }
    /**
     * If JYear is a leap year in jalali Calendar, return true. We using the fact that if a year is leap, number of leap years until that year
     * and the year after it is not equal.
     * @param {?} jYear full jalali year like: 1397
     * @return {?}
     */
    isJYearLeap(jYear) {
        return this.numOfJLeapYears(jYear) !== this.numOfJLeapYears(jYear + 1);
    }
    /**
     * Checks if jalali year is in acceptable range or not.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L27}
     * @param {?} jYear full jalali year like 1397
     * @return {?}
     */
    isValidJYear(jYear) {
        return jYear >= JalaliDateValidatorService._minAcceptableYear && jYear <= JalaliDateValidatorService._maxAcceptableYear;
    }
    /**
     * Checks if jalali month is in valid range or not. In default, jMonth should start from zero.
     * If you want to start month number from one instead of zero, you should make startFromZero parameter to false.
     * @param {?} jMonth
     * @param {?=} startFromZero
     * @return {?}
     */
    isValidJMonth(jMonth, startFromZero = true) {
        /** @type {?} */
        let minMonthNumber = 0;
        /** @type {?} */
        let maxMonthNumber = 11;
        if (!startFromZero) {
            minMonthNumber++;
            maxMonthNumber++;
        }
        return jMonth >= minMonthNumber && jMonth <= maxMonthNumber;
    }
    /**
     * Checks if day number is in valid range according to the given year and month.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth month number starting from zero
     * @param {?} jDay day number starting from one
     * @return {?}
     */
    isValidJDay(jYear, jMonth, jDay) {
        return jDay <= this.jMonthLength(jYear, jMonth) && jDay > 0;
    }
    /**
     * If Jalali date is not a valid Jalali date, return false. otherwise returns true.
     * @param {?} jYear full year number like: 1397
     * @param {?} jMonth starts from zero
     * @param {?} jDay starts from one
     * @return {?}
     */
    isValidJDate(jYear, jMonth, jDay) {
        return this.isValidJYear(jYear) && this.isValidJMonth(jMonth) && this.isValidJDay(jYear, jMonth, jDay);
    }
}
JalaliDateValidatorService._minAcceptableYear = -61;
JalaliDateValidatorService._maxAcceptableYear = 3177;
JalaliDateValidatorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
JalaliDateValidatorService.ctorParameters = () => [];
/** @nocollapse */ JalaliDateValidatorService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function JalaliDateValidatorService_Factory() { return new JalaliDateValidatorService(); }, token: JalaliDateValidatorService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    JalaliDateValidatorService._minAcceptableYear;
    /**
     * @type {?}
     * @private
     */
    JalaliDateValidatorService._maxAcceptableYear;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiamFsYWxpLWRhdGUtdmFsaWRhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtcGVyc2lhbi8iLCJzb3VyY2VzIjpbImxpYi9KRGF0ZS9qYWxhbGktZGF0ZS12YWxpZGF0b3Iuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLDJCQUEyQixDQUFDOzs7Ozs7QUFVakUsTUFBTSxPQUFPLDBCQUEwQjtJQUtyQyxnQkFBZ0IsQ0FBQzs7Ozs7OztJQU9qQixZQUFZLENBQUMsS0FBYSxFQUFFLE1BQWM7UUFDeEMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQUUsT0FBTyxFQUFFLENBQUM7U0FBRTtRQUM5QixJQUFJLE1BQU0sR0FBRyxFQUFFLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUFFLE9BQU8sRUFBRSxDQUFDO1NBQUU7UUFDMUQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDOzs7Ozs7OztJQVNELGVBQWUsQ0FBQyxXQUFtQjs7O2NBRTNCLE1BQU0sR0FBRztZQUNiLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUk7WUFDckQsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJO1NBQ3JEOztjQUVLLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTTs7WUFDOUIsRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7O1lB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dGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2RpdiwgbW9kfSBmcm9tICcuL0FyaXRobWV0aWNVdGlscyc7XG5pbXBvcnQge0ludmFsaWRKYWxhbGlEYXRlRXJyb3J9IGZyb20gJy4vSW52YWxpZEphbGFsaURhdGUuZXJyb3InO1xuXG5cbi8qKlxuICogTWV0aG9kcyBvZiB0aGlzIFNlcnZpY2UgZG9pbmcgdmFsaWRhdGlvbiBzdHVmZiBvbiBhIEphbGFsaSBkYXRlLiBZb3UgY2FuIHVzZSB0aGlzIFNlcnZpY2UgdXNpbmcgREkgaW4gYWxsIGFyb3VuZCBvZiB5b3VyIGFwcCBmb3JcbiAqIHZhbGlkYXRpbmcgSmFsYWxpIGRhdGVzIHdpdGhvdXQgbmVlZGluZyB0byBjb252ZXJ0IHRoZW0gdG8gdGhlIEdlb3JnaWFuIERhdGUuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEphbGFsaURhdGVWYWxpZGF0b3JTZXJ2aWNlIHtcblxuICBwcml2YXRlIHN0YXRpYyBfbWluQWNjZXB0YWJsZVllYXIgPSAtNjE7XG4gIHByaXZhdGUgc3RhdGljIF9tYXhBY2NlcHRhYmxlWWVhciA9IDMxNzc7XG5cbiAgY29uc3RydWN0b3IoKSB7IH1cblxuICAvKipcbiAgICogUmV0dXJucyBudW1iZXIgb2YgZGF5cyBpbiBhIGdpdmVuIG1vbnRoIGNvdW50aW5nIGZyb20gMS5cbiAgICogQHBhcmFtIGpZZWFyIGZ1bGwgamFsYWxpIHllYXIgbGlrZSAxMzk3XG4gICAqIEBwYXJhbSBqTW9udGggbnVtYmVyIG9mIG1vbnRoIGZyb20gMCBmb3IgRmFydmFyZGluIHRvIDExIGZvciBFc2ZhbmQuXG4gICAqL1xuICBqTW9udGhMZW5ndGgoalllYXI6IG51bWJlciwgak1vbnRoOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChqTW9udGggPCA2KSB7IHJldHVybiAzMTsgfVxuICAgIGlmIChqTW9udGggPCAxMSB8fCB0aGlzLmlzSlllYXJMZWFwKGpZZWFyKSkgeyByZXR1cm4gMzA7IH1cbiAgICByZXR1cm4gMjk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgdGhlIGxlYXAgeWVhcnMgaW4gamFsYWxpIENhbGVuZGFyLlxuICAgKiBAcGFyYW0gdGFyZ2V0SlllYXIgc2hvdWxkIGJlIGZ1bGwgeWVhciBsaWtlOiAxMzk3IGFuZCBzaG91bGQgYmUgYmV0d2VlbiAtNjEgdG8gMzE3Ny5cbiAgICpcbiAgICogW0ltcGxlbWVudGF0aW9uIGluIHNvdXJjZSBjb2RlXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2lqYWQvdHMtamFsYWFsaS9ibG9iLzI5NmE3YzJmYTE4MTZhNWJiYjBiMTFiYmUzZWIwM2ViYzE3MDU5ZjYvc3JjL2phbGFhbGkudHMjTDcxfVxuICAgKi9cbiAgbnVtT2ZKTGVhcFllYXJzKHRhcmdldEpZZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIC8vIEphbGFsaSB5ZWFycyBzdGFydGluZyB0aGUgMzMteWVhciBydWxlLlxuICAgIGNvbnN0IGJyZWFrcyA9IFtcbiAgICAgIC02MSwgOSwgMzgsIDE5OSwgNDI2LCA2ODYsIDc1NiwgODE4LCAxMTExLCAxMTgxLCAxMjEwLFxuICAgICAgMTYzNSwgMjA2MCwgMjA5NywgMjE5MiwgMjI2MiwgMjMyNCwgMjM5NCwgMjQ1NiwgMzE3OCxcbiAgICBdO1xuXG4gICAgY29uc3QgYnJlYWtzTGVuZ3RoID0gYnJlYWtzLmxlbmd0aDtcbiAgICBsZXQganAgPSBicmVha3NbMF07XG4gICAgbGV0IGp1bXA6IG51bWJlcjtcbiAgICBsZXQgbGVhcEogPSAtMTQ7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEpZZWFyKHRhcmdldEpZZWFyKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRKYWxhbGlEYXRlRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBsaW1pdGluZyB5ZWFycyBmb3IgdGhlIEphbGFsaSB5ZWFyIGp5LlxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYnJlYWtzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGptID0gYnJlYWtzW2ldO1xuICAgICAganVtcCA9IGptIC0ganA7XG4gICAgICBpZiAodGFyZ2V0SlllYXIgPCBqbSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxlYXBKID0gbGVhcEogKyBkaXYoanVtcCwgMzMpICogOCArIGRpdihtb2QoanVtcCwgMzMpLCA0KTtcbiAgICAgIGpwID0gam07XG4gICAgfVxuICAgIGNvbnN0IG4gPSB0YXJnZXRKWWVhciAtIGpwO1xuXG4gICAgLy8gRmluZCB0aGUgbnVtYmVyIG9mIGxlYXAgeWVhcnMgZnJvbSBBRCA2MjEgdG8gdGhlIGJlZ2lubmluZ1xuICAgIC8vIG9mIHRoZSBjdXJyZW50IEphbGFsaSB5ZWFyIGluIHRoZSBQZXJzaWFuIENhbGVuZGFyLlxuICAgIGxlYXBKID0gbGVhcEogKyBkaXYobiwgMzMpICogOCArIGRpdihtb2QobiwgMzMpICsgMywgNCk7XG5cbiAgICBpZiAobW9kKGp1bXAsIDMzKSA9PT0gNCAmJiBqdW1wIC0gbiA9PT0gNCkge1xuICAgICAgbGVhcEogKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXBKO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIEpZZWFyIGlzIGEgbGVhcCB5ZWFyIGluIGphbGFsaSBDYWxlbmRhciwgcmV0dXJuIHRydWUuIFdlIHVzaW5nIHRoZSBmYWN0IHRoYXQgaWYgYSB5ZWFyIGlzIGxlYXAsIG51bWJlciBvZiBsZWFwIHllYXJzIHVudGlsIHRoYXQgeWVhclxuICAgKiBhbmQgdGhlIHllYXIgYWZ0ZXIgaXQgaXMgbm90IGVxdWFsLlxuICAgKiBAcGFyYW0galllYXIgZnVsbCBqYWxhbGkgeWVhciBsaWtlOiAxMzk3XG4gICAqL1xuICBpc0pZZWFyTGVhcChqWWVhcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubnVtT2ZKTGVhcFllYXJzKGpZZWFyKSAhPT0gdGhpcy5udW1PZkpMZWFwWWVhcnMoalllYXIgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgamFsYWxpIHllYXIgaXMgaW4gYWNjZXB0YWJsZSByYW5nZSBvciBub3QuXG4gICAqXG4gICAqIFtJbXBsZW1lbnRhdGlvbiBpbiBzb3VyY2UgY29kZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NpamFkL3RzLWphbGFhbGkvYmxvYi8yOTZhN2MyZmExODE2YTViYmIwYjExYmJlM2ViMDNlYmMxNzA1OWY2L3NyYy9qYWxhYWxpLnRzI0wyN31cbiAgICogQHBhcmFtIGpZZWFyIGZ1bGwgamFsYWxpIHllYXIgbGlrZSAxMzk3XG4gICAqL1xuICBpc1ZhbGlkSlllYXIoalllYXI6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBqWWVhciA+PSBKYWxhbGlEYXRlVmFsaWRhdG9yU2VydmljZS5fbWluQWNjZXB0YWJsZVllYXIgJiYgalllYXIgPD0gSmFsYWxpRGF0ZVZhbGlkYXRvclNlcnZpY2UuX21heEFjY2VwdGFibGVZZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBqYWxhbGkgbW9udGggaXMgaW4gdmFsaWQgcmFuZ2Ugb3Igbm90LiBJbiBkZWZhdWx0LCBqTW9udGggc2hvdWxkIHN0YXJ0IGZyb20gemVyby5cbiAgICogSWYgeW91IHdhbnQgdG8gc3RhcnQgbW9udGggbnVtYmVyIGZyb20gb25lIGluc3RlYWQgb2YgemVybywgeW91IHNob3VsZCBtYWtlIHN0YXJ0RnJvbVplcm8gcGFyYW1ldGVyIHRvIGZhbHNlLlxuICAgKi9cbiAgaXNWYWxpZEpNb250aChqTW9udGg6IG51bWJlciwgc3RhcnRGcm9tWmVybzogYm9vbGVhbiA9IHRydWUpOiBib29sZWFuIHtcbiAgICBsZXQgbWluTW9udGhOdW1iZXIgPSAwO1xuICAgIGxldCBtYXhNb250aE51bWJlciA9IDExO1xuICAgIGlmICghc3RhcnRGcm9tWmVybykge1xuICAgICAgbWluTW9udGhOdW1iZXIrKztcbiAgICAgIG1heE1vbnRoTnVtYmVyKys7XG4gICAgfVxuICAgIHJldHVybiBqTW9udGggPj0gbWluTW9udGhOdW1iZXIgJiYgak1vbnRoIDw9IG1heE1vbnRoTnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBkYXkgbnVtYmVyIGlzIGluIHZhbGlkIHJhbmdlIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4geWVhciBhbmQgbW9udGguXG4gICAqIEBwYXJhbSBqWWVhciBmdWxsIGphbGFsaSB5ZWFyIGxpa2UgMTM5N1xuICAgKiBAcGFyYW0gak1vbnRoIG1vbnRoIG51bWJlciBzdGFydGluZyBmcm9tIHplcm9cbiAgICogQHBhcmFtIGpEYXkgZGF5IG51bWJlciBzdGFydGluZyBmcm9tIG9uZVxuICAgKi9cbiAgaXNWYWxpZEpEYXkoalllYXI6IG51bWJlciwgak1vbnRoOiBudW1iZXIsIGpEYXk6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBqRGF5IDw9IHRoaXMuak1vbnRoTGVuZ3RoKGpZZWFyLCBqTW9udGgpICYmIGpEYXkgPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIEphbGFsaSBkYXRlIGlzIG5vdCBhIHZhbGlkIEphbGFsaSBkYXRlLCByZXR1cm4gZmFsc2UuIG90aGVyd2lzZSByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSBqWWVhciBmdWxsIHllYXIgbnVtYmVyIGxpa2U6IDEzOTdcbiAgICogQHBhcmFtIGpNb250aCBzdGFydHMgZnJvbSB6ZXJvXG4gICAqIEBwYXJhbSBqRGF5IHN0YXJ0cyBmcm9tIG9uZVxuICAgKi9cbiAgaXNWYWxpZEpEYXRlKGpZZWFyOiBudW1iZXIsIGpNb250aDogbnVtYmVyLCBqRGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkSlllYXIoalllYXIpICYmIHRoaXMuaXNWYWxpZEpNb250aChqTW9udGgpICYmIHRoaXMuaXNWYWxpZEpEYXkoalllYXIsIGpNb250aCwgakRheSk7XG4gIH1cbn1cbiJdfQ==