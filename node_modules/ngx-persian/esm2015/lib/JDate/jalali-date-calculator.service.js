/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { div, mod } from './ArithmeticUtils';
import { InvalidJalaliDateError } from './InvalidJalaliDate.error';
import { JalaliDateValidatorService } from './jalali-date-validator.service';
import * as i0 from "@angular/core";
import * as i1 from "./jalali-date-validator.service";
/**
 * This class converts Jalali date to Georgian and vase versa. You can use all of the methods as static methods.
 *
 */
export class JalaliDateCalculatorService {
    /**
     * @param {?} validator
     */
    constructor(validator) {
        this.validator = validator;
    }
    /**
     * Calculates the Julian Day number from Gregorian or Julian calendar dates.
     *
     * Only some code cleaning applied to the source code.
     *
     * The procedure was tested to be good since 1 March, -100100 (of both calendars) up to a few million years into the future.
     *
     * @param {?} gDate an instance of javascript date representing a Georgian date.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L195}
     * @return {?}
     */
    numberOfPassedGDays(gDate) {
        /** @type {?} */
        const gMonth = gDate.getMonth() - 7;
        /** @type {?} */
        const gYear = gDate.getFullYear() + 100100;
        /** @type {?} */
        const gMonthDiv = div(gMonth, 6);
        /** @type {?} */
        const result = div((gYear + gMonthDiv) * 1461, 4) + div(153 * mod(gMonth + 17, 12) + 2, 5) + gDate.getDate() - 34840408;
        return result - div(div(gYear + gMonthDiv, 100) * 3, 4) + 752;
    }
    /**
     * Returns number of passed days from source day in jalali calendar to the given jalali date.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth starts from zero
     * @param {?} jDay day number starts from one
     * @return {?}
     */
    numberOfPassedJDays(jYear, jMonth, jDay) {
        return this.numberOfPassedGDays(new Date(this.jalaliYearToGeorgianYear(jYear), 2, this.firstDayOfJYearInMarch(jYear))) +
            jMonth * 31 - div(jMonth + 1, 7) * (jMonth - 6) + jDay - 1;
    }
    /**
     * Creates a javascript Date object from number of passed days in Georgian calendar representing Georgian date.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L213}
     * @param {?} numOfDays
     * @return {?}
     */
    createGDateFromDays(numOfDays) {
        /** @type {?} */
        const j = (4 * numOfDays + 139361631) + div(div(4 * numOfDays + 183187720, 146097) * 3, 4) * 4 - 3908;
        /** @type {?} */
        const i = div(mod(j, 1461), 4) * 5 + 308;
        /** @type {?} */
        const gDay = div(mod(i, 153), 5) + 1;
        /** @type {?} */
        const gMonth = mod(div(i, 153), 12);
        /** @type {?} */
        const gYear = div(j, 1461) - 100100 + div(7 - gMonth, 6);
        return new Date(gYear, gMonth, gDay);
    }
    /**
     * This function returns number of passed leap years from AD 621 until targetGYear.
     * @param {?} targetGYear is full year number like 2018
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L110}
     * @return {?}
     */
    numOfGLeapYears(targetGYear) {
        return div(targetGYear, 4) - div((div(targetGYear, 100) + 1) * 3, 4) - 150;
    }
    /**
     * first day of the Farvardin month in Jalali calendar is in March month. This method returns the day number of new jalali year in March.
     * The day number starts from 1 not zero and is equal to the real numbers in the calendar.
     * @param {?} jYear full jalali year like 1397
     * @return {?}
     */
    firstDayOfJYearInMarch(jYear) {
        /** @type {?} */
        const gYear = jYear + 621;
        return this.validator.numOfJLeapYears(jYear) - this.numOfGLeapYears(gYear) + 20;
    }
    /**
     * Converts jalali year number to the georgian year. Output year is the georgian year that jalali year starts within it, not the year
     * that starts in the winter of jalali year.
     * @param {?} jYear full jalali year like 1397
     * @return {?}
     */
    jalaliYearToGeorgianYear(jYear) {
        return jYear + 621;
    }
    /**
     * Converts georgian year to the jalali year. Output year is the jalali year that start within the Georgian year.
     * @param {?} gYear full georgian year like 2018
     * @return {?}
     */
    georgianYearToJalaliYear(gYear) {
        return gYear - 621;
    }
    /**
     * this method converts Georgian date to the jalali date. Output is an object implementing SimpleDateInterface.
     *
     * ATTENTION: month number starts from 0, but day number starts from 1. Just like native javascript Date object.
     * @param {?} gDate Georgian date as a javascript Date object.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L149}
     * @return {?}
     */
    convertToJalali(gDate) {
        /** @type {?} */
        const georgianYear = gDate.getFullYear();
        /** @type {?} */
        let jalaliYear = this.georgianYearToJalaliYear(georgianYear);
        /** @type {?} */
        const passedDays = this.numberOfPassedGDays(gDate);
        /** @type {?} */
        const numOfPassedDaysTo1Farvardin = this.numberOfPassedGDays(new Date(georgianYear, 2, this.firstDayOfJYearInMarch(jalaliYear)));
        /** @type {?} */
        let jalaliDay;
        /** @type {?} */
        let jalaliMonth;
        // Find number of days that passed since 1 Farvardin.
        /** @type {?} */
        let numOfDayInJYear = passedDays - numOfPassedDaysTo1Farvardin;
        if (numOfDayInJYear >= 0) {
            if (numOfDayInJYear <= 185) {
                // The first 6 months.
                jalaliMonth = div(numOfDayInJYear, 31);
                jalaliDay = mod(numOfDayInJYear, 31) + 1;
                return { year: jalaliYear, month: jalaliMonth, day: jalaliDay };
            }
            else {
                // The remaining months.
                numOfDayInJYear -= 186;
            }
        }
        else {
            // Previous Jalali year.
            jalaliYear -= 1;
            numOfDayInJYear += 179;
            if (this.validator.isJYearLeap(jalaliYear)) {
                numOfDayInJYear += 1;
            }
        }
        jalaliMonth = 6 + div(numOfDayInJYear, 30);
        jalaliDay = mod(numOfDayInJYear, 30) + 1;
        return { year: jalaliYear, month: jalaliMonth, day: jalaliDay };
    }
    /**
     * Converts a valid jalali date to a javascript Date object representing a equivalent Georgian date.
     * @throws InvalidJalaliDateError when inputted date is not a valid Jalali date.
     * @param {?} jYear a full Jalali year like 1397
     * @param {?} jMonth starts from zero
     * @param {?} jDay starts from 1
     * @return {?}
     */
    convertToGeorgian(jYear, jMonth, jDay) {
        if (!this.validator.isValidJDate(jYear, jMonth, jDay)) {
            throw new InvalidJalaliDateError();
        }
        return this.createGDateFromDays(this.numberOfPassedJDays(jYear, jMonth, jDay));
    }
}
JalaliDateCalculatorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
JalaliDateCalculatorService.ctorParameters = () => [
    { type: JalaliDateValidatorService }
];
/** @nocollapse */ JalaliDateCalculatorService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function JalaliDateCalculatorService_Factory() { return new JalaliDateCalculatorService(i0.ɵɵinject(i1.JalaliDateValidatorService)); }, token: JalaliDateCalculatorService, providedIn: "root" });
if (false) {
    /** @type {?} */
    JalaliDateCalculatorService.prototype.validator;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiamFsYWxpLWRhdGUtY2FsY3VsYXRvci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXBlcnNpYW4vIiwic291cmNlcyI6WyJsaWIvSkRhdGUvamFsYWxpLWRhdGUtY2FsY3VsYXRvci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDM0MsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFFakUsT0FBTyxFQUFDLDBCQUEwQixFQUFDLE1BQU0saUNBQWlDLENBQUM7Ozs7Ozs7QUFTM0UsTUFBTSxPQUFPLDJCQUEyQjs7OztJQUV0QyxZQUFtQixTQUFxQztRQUFyQyxjQUFTLEdBQVQsU0FBUyxDQUE0QjtJQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7SUFjNUQsbUJBQW1CLENBQUMsS0FBVzs7Y0FDdkIsTUFBTSxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDOztjQUM3QixLQUFLLEdBQUcsS0FBSyxDQUFDLFdBQVcsRUFBRSxHQUFHLE1BQU07O2NBQ3BDLFNBQVMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQzs7Y0FDMUIsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sRUFBRSxHQUFHLFFBQVE7UUFDdkgsT0FBTyxNQUFNLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsU0FBUyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENB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QU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDakYsQ0FBQzs7O1lBN0lGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7OztZQVJPLDBCQUEwQjs7Ozs7SUFXcEIsZ0RBQTRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7ZGl2LCBtb2R9IGZyb20gJy4vQXJpdGhtZXRpY1V0aWxzJztcbmltcG9ydCB7SW52YWxpZEphbGFsaURhdGVFcnJvcn0gZnJvbSAnLi9JbnZhbGlkSmFsYWxpRGF0ZS5lcnJvcic7XG5pbXBvcnQge1NpbXBsZURhdGVJbnRlcmZhY2V9IGZyb20gJy4vU2ltcGxlRGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHtKYWxhbGlEYXRlVmFsaWRhdG9yU2VydmljZX0gZnJvbSAnLi9qYWxhbGktZGF0ZS12YWxpZGF0b3Iuc2VydmljZSc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBjb252ZXJ0cyBKYWxhbGkgZGF0ZSB0byBHZW9yZ2lhbiBhbmQgdmFzZSB2ZXJzYS4gWW91IGNhbiB1c2UgYWxsIG9mIHRoZSBtZXRob2RzIGFzIHN0YXRpYyBtZXRob2RzLlxuICpcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgSmFsYWxpRGF0ZUNhbGN1bGF0b3JTZXJ2aWNlIHtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsaWRhdG9yOiBKYWxhbGlEYXRlVmFsaWRhdG9yU2VydmljZSkge31cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgSnVsaWFuIERheSBudW1iZXIgZnJvbSBHcmVnb3JpYW4gb3IgSnVsaWFuIGNhbGVuZGFyIGRhdGVzLlxuICAgKlxuICAgKiBPbmx5IHNvbWUgY29kZSBjbGVhbmluZyBhcHBsaWVkIHRvIHRoZSBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogVGhlIHByb2NlZHVyZSB3YXMgdGVzdGVkIHRvIGJlIGdvb2Qgc2luY2UgMSBNYXJjaCwgLTEwMDEwMCAob2YgYm90aCBjYWxlbmRhcnMpIHVwIHRvIGEgZmV3IG1pbGxpb24geWVhcnMgaW50byB0aGUgZnV0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0gZ0RhdGUgYW4gaW5zdGFuY2Ugb2YgamF2YXNjcmlwdCBkYXRlIHJlcHJlc2VudGluZyBhIEdlb3JnaWFuIGRhdGUuXG4gICAqXG4gICAqIFtJbXBsZW1lbnRhdGlvbiBpbiBzb3VyY2UgY29kZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NpamFkL3RzLWphbGFhbGkvYmxvYi8yOTZhN2MyZmExODE2YTViYmIwYjExYmJlM2ViMDNlYmMxNzA1OWY2L3NyYy9qYWxhYWxpLnRzI0wxOTV9XG5cbiAgICovXG4gIG51bWJlck9mUGFzc2VkR0RheXMoZ0RhdGU6IERhdGUpOiBudW1iZXIge1xuICAgIGNvbnN0IGdNb250aCA9IGdEYXRlLmdldE1vbnRoKCkgLSA3O1xuICAgIGNvbnN0IGdZZWFyID0gZ0RhdGUuZ2V0RnVsbFllYXIoKSArIDEwMDEwMDtcbiAgICBjb25zdCBnTW9udGhEaXYgPSBkaXYoZ01vbnRoLCA2KTtcbiAgICBjb25zdCByZXN1bHQgPSBkaXYoKGdZZWFyICsgZ01vbnRoRGl2KSAqIDE0NjEsIDQpICsgZGl2KDE1MyAqIG1vZChnTW9udGggKyAxNywgMTIpICsgMiwgNSkgKyBnRGF0ZS5nZXREYXRlKCkgLSAzNDg0MDQwODtcbiAgICByZXR1cm4gcmVzdWx0IC0gZGl2KGRpdihnWWVhciArIGdNb250aERpdiwgMTAwKSAqIDMsIDQpICsgNzUyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIHBhc3NlZCBkYXlzIGZyb20gc291cmNlIGRheSBpbiBqYWxhbGkgY2FsZW5kYXIgdG8gdGhlIGdpdmVuIGphbGFsaSBkYXRlLlxuICAgKiBAcGFyYW0galllYXIgZnVsbCBqYWxhbGkgeWVhciBsaWtlIDEzOTdcbiAgICogQHBhcmFtIGpNb250aCBzdGFydHMgZnJvbSB6ZXJvXG4gICAqIEBwYXJhbSBqRGF5IGRheSBudW1iZXIgc3RhcnRzIGZyb20gb25lXG4gICAqL1xuICBudW1iZXJPZlBhc3NlZEpEYXlzKGpZZWFyOiBudW1iZXIsIGpNb250aDogbnVtYmVyLCBqRGF5OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm51bWJlck9mUGFzc2VkR0RheXMobmV3IERhdGUodGhpcy5qYWxhbGlZZWFyVG9HZW9yZ2lhblllYXIoalllYXIpLCAyLCB0aGlzLmZpcnN0RGF5T2ZKWWVhckluTWFyY2goalllYXIpKSkgK1xuICAgICAgak1vbnRoICogMzEgLSBkaXYoak1vbnRoICsgMSwgNykgKiAoak1vbnRoIC0gNikgKyBqRGF5IC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgamF2YXNjcmlwdCBEYXRlIG9iamVjdCBmcm9tIG51bWJlciBvZiBwYXNzZWQgZGF5cyBpbiBHZW9yZ2lhbiBjYWxlbmRhciByZXByZXNlbnRpbmcgR2VvcmdpYW4gZGF0ZS5cbiAgICpcbiAgICogW0ltcGxlbWVudGF0aW9uIGluIHNvdXJjZSBjb2RlXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2lqYWQvdHMtamFsYWFsaS9ibG9iLzI5NmE3YzJmYTE4MTZhNWJiYjBiMTFiYmUzZWIwM2ViYzE3MDU5ZjYvc3JjL2phbGFhbGkudHMjTDIxM31cbiAgICovXG4gIGNyZWF0ZUdEYXRlRnJvbURheXMobnVtT2ZEYXlzOiBudW1iZXIpOiBEYXRlIHtcbiAgICBjb25zdCBqID0gKDQgKiBudW1PZkRheXMgKyAxMzkzNjE2MzEpICsgZGl2KGRpdig0ICogbnVtT2ZEYXlzICsgMTgzMTg3NzIwLCAxNDYwOTcpICogMywgNCkgKiA0IC0gMzkwODtcbiAgICBjb25zdCBpID0gZGl2KG1vZChqLCAxNDYxKSwgNCkgKiA1ICsgMzA4O1xuICAgIGNvbnN0IGdEYXkgPSBkaXYobW9kKGksIDE1MyksIDUpICsgMTtcbiAgICBjb25zdCBnTW9udGggPSBtb2QoZGl2KGksIDE1MyksIDEyKTtcbiAgICBjb25zdCBnWWVhciA9IGRpdihqLCAxNDYxKSAtIDEwMDEwMCArIGRpdig3IC0gZ01vbnRoLCA2KTtcbiAgICByZXR1cm4gbmV3IERhdGUoZ1llYXIsIGdNb250aCwgZ0RheSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIG51bWJlciBvZiBwYXNzZWQgbGVhcCB5ZWFycyBmcm9tIEFEIDYyMSB1bnRpbCB0YXJnZXRHWWVhci5cbiAgICogQHBhcmFtIHRhcmdldEdZZWFyIGlzIGZ1bGwgeWVhciBudW1iZXIgbGlrZSAyMDE4XG4gICAqXG4gICAqIFtJbXBsZW1lbnRhdGlvbiBpbiBzb3VyY2UgY29kZV17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NpamFkL3RzLWphbGFhbGkvYmxvYi8yOTZhN2MyZmExODE2YTViYmIwYjExYmJlM2ViMDNlYmMxNzA1OWY2L3NyYy9qYWxhYWxpLnRzI0wxMTB9XG4gICAqL1xuICBudW1PZkdMZWFwWWVhcnModGFyZ2V0R1llYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGRpdih0YXJnZXRHWWVhciwgNCkgLSBkaXYoKGRpdih0YXJnZXRHWWVhciwgMTAwKSArIDEpICogMywgNCkgLSAxNTA7XG4gIH1cblxuICAvKipcbiAgICogZmlyc3QgZGF5IG9mIHRoZSBGYXJ2YXJkaW4gbW9udGggaW4gSmFsYWxpIGNhbGVuZGFyIGlzIGluIE1hcmNoIG1vbnRoLiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBkYXkgbnVtYmVyIG9mIG5ldyBqYWxhbGkgeWVhciBpbiBNYXJjaC5cbiAgICogVGhlIGRheSBudW1iZXIgc3RhcnRzIGZyb20gMSBub3QgemVybyBhbmQgaXMgZXF1YWwgdG8gdGhlIHJlYWwgbnVtYmVycyBpbiB0aGUgY2FsZW5kYXIuXG4gICAqIEBwYXJhbSBqWWVhciBmdWxsIGphbGFsaSB5ZWFyIGxpa2UgMTM5N1xuICAgKi9cbiAgZmlyc3REYXlPZkpZZWFySW5NYXJjaChqWWVhcik6IG51bWJlciB7XG4gICAgY29uc3QgZ1llYXIgPSBqWWVhciArIDYyMTtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IubnVtT2ZKTGVhcFllYXJzKGpZZWFyKSAtIHRoaXMubnVtT2ZHTGVhcFllYXJzKGdZZWFyKSArIDIwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGphbGFsaSB5ZWFyIG51bWJlciB0byB0aGUgZ2VvcmdpYW4geWVhci4gT3V0cHV0IHllYXIgaXMgdGhlIGdlb3JnaWFuIHllYXIgdGhhdCBqYWxhbGkgeWVhciBzdGFydHMgd2l0aGluIGl0LCBub3QgdGhlIHllYXJcbiAgICogdGhhdCBzdGFydHMgaW4gdGhlIHdpbnRlciBvZiBqYWxhbGkgeWVhci5cbiAgICogQHBhcmFtIGpZZWFyIGZ1bGwgamFsYWxpIHllYXIgbGlrZSAxMzk3XG4gICAqL1xuICBqYWxhbGlZZWFyVG9HZW9yZ2lhblllYXIoalllYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGpZZWFyICsgNjIxO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGdlb3JnaWFuIHllYXIgdG8gdGhlIGphbGFsaSB5ZWFyLiBPdXRwdXQgeWVhciBpcyB0aGUgamFsYWxpIHllYXIgdGhhdCBzdGFydCB3aXRoaW4gdGhlIEdlb3JnaWFuIHllYXIuXG4gICAqIEBwYXJhbSBnWWVhciBmdWxsIGdlb3JnaWFuIHllYXIgbGlrZSAyMDE4XG4gICAqL1xuICBnZW9yZ2lhblllYXJUb0phbGFsaVllYXIoZ1llYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGdZZWFyIC0gNjIxO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgbWV0aG9kIGNvbnZlcnRzIEdlb3JnaWFuIGRhdGUgdG8gdGhlIGphbGFsaSBkYXRlLiBPdXRwdXQgaXMgYW4gb2JqZWN0IGltcGxlbWVudGluZyBTaW1wbGVEYXRlSW50ZXJmYWNlLlxuICAgKlxuICAgKiBBVFRFTlRJT046IG1vbnRoIG51bWJlciBzdGFydHMgZnJvbSAwLCBidXQgZGF5IG51bWJlciBzdGFydHMgZnJvbSAxLiBKdXN0IGxpa2UgbmF0aXZlIGphdmFzY3JpcHQgRGF0ZSBvYmplY3QuXG4gICAqIEBwYXJhbSBnRGF0ZSBHZW9yZ2lhbiBkYXRlIGFzIGEgamF2YXNjcmlwdCBEYXRlIG9iamVjdC5cbiAgICpcbiAgICogW0ltcGxlbWVudGF0aW9uIGluIHNvdXJjZSBjb2RlXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2lqYWQvdHMtamFsYWFsaS9ibG9iLzI5NmE3YzJmYTE4MTZhNWJiYjBiMTFiYmUzZWIwM2ViYzE3MDU5ZjYvc3JjL2phbGFhbGkudHMjTDE0OX1cbiAgICovXG4gIGNvbnZlcnRUb0phbGFsaShnRGF0ZTogRGF0ZSk6IFNpbXBsZURhdGVJbnRlcmZhY2Uge1xuICAgIGNvbnN0IGdlb3JnaWFuWWVhciA9IGdEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgbGV0IGphbGFsaVllYXIgPSB0aGlzLmdlb3JnaWFuWWVhclRvSmFsYWxpWWVhcihnZW9yZ2lhblllYXIpO1xuICAgIGNvbnN0IHBhc3NlZERheXMgPSB0aGlzLm51bWJlck9mUGFzc2VkR0RheXMoZ0RhdGUpO1xuICAgIGNvbnN0IG51bU9mUGFzc2VkRGF5c1RvMUZhcnZhcmRpbiA9IHRoaXMubnVtYmVyT2ZQYXNzZWRHRGF5cyhuZXcgRGF0ZShnZW9yZ2lhblllYXIsIDIsIHRoaXMuZmlyc3REYXlPZkpZZWFySW5NYXJjaChqYWxhbGlZZWFyKSkpO1xuXG4gICAgbGV0IGphbGFsaURheTogbnVtYmVyO1xuICAgIGxldCBqYWxhbGlNb250aDogbnVtYmVyO1xuXG4gICAgLy8gRmluZCBudW1iZXIgb2YgZGF5cyB0aGF0IHBhc3NlZCBzaW5jZSAxIEZhcnZhcmRpbi5cbiAgICBsZXQgbnVtT2ZEYXlJbkpZZWFyID0gcGFzc2VkRGF5cyAtIG51bU9mUGFzc2VkRGF5c1RvMUZhcnZhcmRpbjtcbiAgICBpZiAobnVtT2ZEYXlJbkpZZWFyID49IDApIHtcbiAgICAgIGlmIChudW1PZkRheUluSlllYXIgPD0gMTg1KSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCA2IG1vbnRocy5cbiAgICAgICAgamFsYWxpTW9udGggPSBkaXYobnVtT2ZEYXlJbkpZZWFyLCAzMSk7XG4gICAgICAgIGphbGFsaURheSA9IG1vZChudW1PZkRheUluSlllYXIsIDMxKSArIDE7XG4gICAgICAgIHJldHVybiAge3llYXI6IGphbGFsaVllYXIsIG1vbnRoOiBqYWxhbGlNb250aCwgZGF5OiBqYWxhbGlEYXl9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBtb250aHMuXG4gICAgICAgIG51bU9mRGF5SW5KWWVhciAtPSAxODY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByZXZpb3VzIEphbGFsaSB5ZWFyLlxuICAgICAgamFsYWxpWWVhciAtPSAxO1xuICAgICAgbnVtT2ZEYXlJbkpZZWFyICs9IDE3OTtcbiAgICAgIGlmICh0aGlzLnZhbGlkYXRvci5pc0pZZWFyTGVhcChqYWxhbGlZZWFyKSkge1xuICAgICAgICBudW1PZkRheUluSlllYXIgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgamFsYWxpTW9udGggPSA2ICsgZGl2KG51bU9mRGF5SW5KWWVhciwgMzApO1xuICAgIGphbGFsaURheSA9IG1vZChudW1PZkRheUluSlllYXIsIDMwKSArIDE7XG4gICAgcmV0dXJuIHt5ZWFyOiBqYWxhbGlZZWFyLCBtb250aDogamFsYWxpTW9udGgsIGRheTogamFsYWxpRGF5fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHZhbGlkIGphbGFsaSBkYXRlIHRvIGEgamF2YXNjcmlwdCBEYXRlIG9iamVjdCByZXByZXNlbnRpbmcgYSBlcXVpdmFsZW50IEdlb3JnaWFuIGRhdGUuXG4gICAqIEBwYXJhbSBqWWVhciBhIGZ1bGwgSmFsYWxpIHllYXIgbGlrZSAxMzk3XG4gICAqIEBwYXJhbSBqTW9udGggc3RhcnRzIGZyb20gemVyb1xuICAgKiBAcGFyYW0gakRheSBzdGFydHMgZnJvbSAxXG4gICAqIEB0aHJvd3MgSW52YWxpZEphbGFsaURhdGVFcnJvciB3aGVuIGlucHV0dGVkIGRhdGUgaXMgbm90IGEgdmFsaWQgSmFsYWxpIGRhdGUuXG4gICAqL1xuICBjb252ZXJ0VG9HZW9yZ2lhbihqWWVhcjogbnVtYmVyLCBqTW9udGg6IG51bWJlciwgakRheTogbnVtYmVyKTogRGF0ZSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRvci5pc1ZhbGlkSkRhdGUoalllYXIsIGpNb250aCwgakRheSkpIHsgdGhyb3cgbmV3IEludmFsaWRKYWxhbGlEYXRlRXJyb3IoKTsgfVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUdEYXRlRnJvbURheXModGhpcy5udW1iZXJPZlBhc3NlZEpEYXlzKGpZZWFyLCBqTW9udGgsIGpEYXkpKTtcbiAgfVxuXG59XG4iXX0=