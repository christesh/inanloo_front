/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { InvalidNationalCodeError } from './InvalidNationalCode.error';
import * as i0 from "@angular/core";
/**
 * For validating Iranian National code (number), you can use this service in your components or every other places using DI or not.
 */
export class NationalCodeService {
    /**
     *
     * [We are using for loop instead of match or split because it has better performance according to this link]{\@link https://stackoverflow.com/a/46312614/5400597}
     * @private
     * @param {?} input
     * @return {?} true if all characters of the `input` are equal and input length is greater than 1. Otherwise returns false.
     */
    _is_repetitive(input) {
        if (input.length < 2) {
            return false;
        }
        /** @type {?} */
        const firstChar = input.charAt(0);
        for (let i = 1; i < input.length; i++) {
            if (input.charAt(i) !== firstChar) {
                return false;
            }
        }
        return true;
    }
    /**
     * This method adds zero character at the beginning of the input until the length of the result reach to 10.
     *
     * This method removes spaces from right and left sides of the input.
     *
     * ATTENTION: This method doesn't any validation about correctness of the input if it has correct length (between 8 and 10).
     * @throws InvalidNationalCodeError when length of the input value is greater than 10.
     * @param {?} nationalCode a number with at most 10 digits or a string with at most 10 character.
     * @return {?} a string with length equal to 10.
     */
    normalize(nationalCode) {
        if (!nationalCode) {
            throw new InvalidNationalCodeError();
        }
        nationalCode = nationalCode.toString();
        nationalCode = nationalCode.trim();
        /** @type {?} */
        const nationalCodeLength = nationalCode.length;
        if (nationalCodeLength > 10 || nationalCodeLength < 8) {
            throw new InvalidNationalCodeError(nationalCode);
        }
        return '0'.repeat(10 - nationalCodeLength) + nationalCode;
    }
    /**
     * This method first normalizes the input using `normalize` method and implicitly checks input length, So you DO NOT NEED to
     * normalize input before, but this will not make any bad effect.
     *
     * [Then checking validation of the input using algorithm described in this link]{\@link http://www.aliarash.com/article/codemeli/codemeli.htm}
     * @param {?} nationalCode
     * @return {?}
     */
    isValid(nationalCode) {
        if (!nationalCode) {
            return false;
        }
        nationalCode = nationalCode.toString();
        if (this._is_repetitive(nationalCode)) {
            return false;
        }
        try {
            nationalCode = this.normalize(nationalCode); // Normalizing the input and checking input length validation implicitly.
        }
        catch (e) {
            return false; // Input length is not in the valid range.
        }
        /** @type {?} */
        let multiplicationResult = 0;
        for (let i = 0; i < 9; i++) {
            multiplicationResult += parseInt(nationalCode.charAt(i), 10) * (10 - i);
        }
        /** @type {?} */
        const reminder = multiplicationResult % 11;
        /** @type {?} */
        const controlNum = parseInt(nationalCode.charAt(9));
        /** @type {?} */
        let desiredControlNum = reminder;
        if (reminder > 1) {
            desiredControlNum = 11 - reminder;
        }
        return desiredControlNum === controlNum;
    }
}
NationalCodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NationalCodeService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function NationalCodeService_Factory() { return new NationalCodeService(); }, token: NationalCodeService, providedIn: "root" });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aW9uYWwtY29kZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXBlcnNpYW4vIiwic291cmNlcyI6WyJsaWIvU2VydmljZXMvbmF0aW9uYWwtY29kZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBQyx3QkFBd0IsRUFBQyxNQUFNLDZCQUE2QixDQUFDOzs7OztBQVFyRSxNQUFNLE9BQU8sbUJBQW1COzs7Ozs7OztJQVF0QixjQUFjLENBQUMsS0FBYTtRQUNsQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQUUsT0FBTyxLQUFLLENBQUM7U0FBRTs7Y0FDakMsU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3JDLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7YUFBRTtTQUNyRDtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQzs7Ozs7Ozs7Ozs7SUFZRCxTQUFTLENBQUMsWUFBNkI7UUFDckMsSUFBSSxDQUFFLFlBQVksRUFBRTtZQUFFLE1BQU0sSUFBSSx3QkFBd0IsRUFBRSxDQUFDO1NBQUU7UUFDN0QsWUFBWSxHQUFHLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN2QyxZQUFZLEdBQUcsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDOztjQUM3QixrQkFBa0IsR0FBRyxZQUFZLENBQUMsTUFBTTtRQUM5QyxJQUFJLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxrQkFBa0IsR0FBRyxDQUFDLEVBQUU7WUFBRSxNQUFNLElBQUksd0JBQXdCLENBQUMsWUFBWSxDQUFDLENBQUM7U0FBRTtRQUM1RyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFHLGtCQUFrQixDQUFDLEdBQUcsWUFBWSxDQUFDO0lBQzVELENBQUM7Ozs7Ozs7OztJQVNELE9BQU8sQ0FBQyxZQUE2QjtRQUNuQyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQUUsT0FBTyxLQUFLLENBQUM7U0FBRTtRQUNwQyxZQUFZLEdBQUcsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3ZDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUFFLE9BQU8sS0FBSyxDQUFDO1NBQUU7UUFDeEQsSUFBSTtZQUNGLFlBQVksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMseUVBQXlFO1NBQ3ZIO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLEtBQUssQ0FBQyxDQUFDLDBDQUEwQztTQUN6RDs7WUFDRyxvQkFBb0IsR0FBRyxDQUFDO1FBQzVCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDMUIsb0JBQW9CLElBQUksUUFBUSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDMUU7O2NBQ0ssUUFBUSxHQUFHLG9CQUFvQixHQUFHLEVBQUU7O2NBQ3BDLFVBQVUsR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7WUFDL0MsaUJBQWlCLEdBQUksUUFBUTtRQUNqQyxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUU7WUFDaEIsaUJBQWlCLEdBQUcsRUFBRSxHQUFHLFFBQVEsQ0FBQztTQUNuQztRQUNELE9BQU8saUJBQWlCLEtBQUssVUFBVSxDQUFDO0lBQzFDLENBQUM7OztZQWxFRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0ludmFsaWROYXRpb25hbENvZGVFcnJvcn0gZnJvbSAnLi9JbnZhbGlkTmF0aW9uYWxDb2RlLmVycm9yJztcblxuLyoqXG4gKiBGb3IgdmFsaWRhdGluZyBJcmFuaWFuIE5hdGlvbmFsIGNvZGUgKG51bWJlciksIHlvdSBjYW4gdXNlIHRoaXMgc2VydmljZSBpbiB5b3VyIGNvbXBvbmVudHMgb3IgZXZlcnkgb3RoZXIgcGxhY2VzIHVzaW5nIERJIG9yIG5vdC5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTmF0aW9uYWxDb2RlU2VydmljZSB7XG5cbiAgLyoqXG4gICAqXG4gICAqIFtXZSBhcmUgdXNpbmcgZm9yIGxvb3AgaW5zdGVhZCBvZiBtYXRjaCBvciBzcGxpdCBiZWNhdXNlIGl0IGhhcyBiZXR0ZXIgcGVyZm9ybWFuY2UgYWNjb3JkaW5nIHRvIHRoaXMgbGlua117QGxpbmsgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MzEyNjE0LzU0MDA1OTd9XG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBvZiB0aGUgYGlucHV0YCBhcmUgZXF1YWwgYW5kIGlucHV0IGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gMS4gT3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXG4gICAqIEBwYXJhbSBpbnB1dFxuICAgKi9cbiAgcHJpdmF0ZSBfaXNfcmVwZXRpdGl2ZShpbnB1dDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8IDIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY29uc3QgZmlyc3RDaGFyID0gaW5wdXQuY2hhckF0KDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQXQoaSkgIT09IGZpcnN0Q2hhcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyB6ZXJvIGNoYXJhY3RlciBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dCB1bnRpbCB0aGUgbGVuZ3RoIG9mIHRoZSByZXN1bHQgcmVhY2ggdG8gMTAuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgc3BhY2VzIGZyb20gcmlnaHQgYW5kIGxlZnQgc2lkZXMgb2YgdGhlIGlucHV0LlxuICAgKlxuICAgKiBBVFRFTlRJT046IFRoaXMgbWV0aG9kIGRvZXNuJ3QgYW55IHZhbGlkYXRpb24gYWJvdXQgY29ycmVjdG5lc3Mgb2YgdGhlIGlucHV0IGlmIGl0IGhhcyBjb3JyZWN0IGxlbmd0aCAoYmV0d2VlbiA4IGFuZCAxMCkuXG4gICAqIEBwYXJhbSBuYXRpb25hbENvZGUgYSBudW1iZXIgd2l0aCBhdCBtb3N0IDEwIGRpZ2l0cyBvciBhIHN0cmluZyB3aXRoIGF0IG1vc3QgMTAgY2hhcmFjdGVyLlxuICAgKiBAcmV0dXJuIGEgc3RyaW5nIHdpdGggbGVuZ3RoIGVxdWFsIHRvIDEwLlxuICAgKiBAdGhyb3dzIEludmFsaWROYXRpb25hbENvZGVFcnJvciB3aGVuIGxlbmd0aCBvZiB0aGUgaW5wdXQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDEwLlxuICAgKi9cbiAgbm9ybWFsaXplKG5hdGlvbmFsQ29kZTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoISBuYXRpb25hbENvZGUpIHsgdGhyb3cgbmV3IEludmFsaWROYXRpb25hbENvZGVFcnJvcigpOyB9XG4gICAgbmF0aW9uYWxDb2RlID0gbmF0aW9uYWxDb2RlLnRvU3RyaW5nKCk7XG4gICAgbmF0aW9uYWxDb2RlID0gbmF0aW9uYWxDb2RlLnRyaW0oKTtcbiAgICBjb25zdCBuYXRpb25hbENvZGVMZW5ndGggPSBuYXRpb25hbENvZGUubGVuZ3RoO1xuICAgIGlmIChuYXRpb25hbENvZGVMZW5ndGggPiAxMCB8fCBuYXRpb25hbENvZGVMZW5ndGggPCA4KSB7IHRocm93IG5ldyBJbnZhbGlkTmF0aW9uYWxDb2RlRXJyb3IobmF0aW9uYWxDb2RlKTsgfVxuICAgIHJldHVybiAnMCcucmVwZWF0KDEwIC0gbmF0aW9uYWxDb2RlTGVuZ3RoKSArIG5hdGlvbmFsQ29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBub3JtYWxpemVzIHRoZSBpbnB1dCB1c2luZyBgbm9ybWFsaXplYCBtZXRob2QgYW5kIGltcGxpY2l0bHkgY2hlY2tzIGlucHV0IGxlbmd0aCwgU28geW91IERPIE5PVCBORUVEIHRvXG4gICAqIG5vcm1hbGl6ZSBpbnB1dCBiZWZvcmUsIGJ1dCB0aGlzIHdpbGwgbm90IG1ha2UgYW55IGJhZCBlZmZlY3QuXG4gICAqXG4gICAqIFtUaGVuIGNoZWNraW5nIHZhbGlkYXRpb24gb2YgdGhlIGlucHV0IHVzaW5nIGFsZ29yaXRobSBkZXNjcmliZWQgaW4gdGhpcyBsaW5rXXtAbGluayBodHRwOi8vd3d3LmFsaWFyYXNoLmNvbS9hcnRpY2xlL2NvZGVtZWxpL2NvZGVtZWxpLmh0bX1cbiAgICogQHBhcmFtIG5hdGlvbmFsQ29kZVxuICAgKi9cbiAgaXNWYWxpZChuYXRpb25hbENvZGU6IG51bWJlciB8IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghbmF0aW9uYWxDb2RlKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG5hdGlvbmFsQ29kZSA9IG5hdGlvbmFsQ29kZS50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLl9pc19yZXBldGl0aXZlKG5hdGlvbmFsQ29kZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgdHJ5IHtcbiAgICAgIG5hdGlvbmFsQ29kZSA9IHRoaXMubm9ybWFsaXplKG5hdGlvbmFsQ29kZSk7IC8vIE5vcm1hbGl6aW5nIHRoZSBpbnB1dCBhbmQgY2hlY2tpbmcgaW5wdXQgbGVuZ3RoIHZhbGlkYXRpb24gaW1wbGljaXRseS5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIElucHV0IGxlbmd0aCBpcyBub3QgaW4gdGhlIHZhbGlkIHJhbmdlLlxuICAgIH1cbiAgICBsZXQgbXVsdGlwbGljYXRpb25SZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBtdWx0aXBsaWNhdGlvblJlc3VsdCArPSBwYXJzZUludChuYXRpb25hbENvZGUuY2hhckF0KGkpLCAxMCkgICogKDEwIC0gaSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbWluZGVyID0gbXVsdGlwbGljYXRpb25SZXN1bHQgJSAxMTtcbiAgICBjb25zdCBjb250cm9sTnVtID0gcGFyc2VJbnQobmF0aW9uYWxDb2RlLmNoYXJBdCg5KSk7XG4gICAgbGV0IGRlc2lyZWRDb250cm9sTnVtID0gIHJlbWluZGVyO1xuICAgIGlmIChyZW1pbmRlciA+IDEpIHtcbiAgICAgIGRlc2lyZWRDb250cm9sTnVtID0gMTEgLSByZW1pbmRlcjtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRDb250cm9sTnVtID09PSBjb250cm9sTnVtO1xuICB9XG59XG4iXX0=