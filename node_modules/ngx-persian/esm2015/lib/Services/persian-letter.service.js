/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { PersianNumberService } from './persian-number.service';
import * as i0 from "@angular/core";
/**
 * isPersian options parameter object should implement this interface. Fields descriptions are in the isPersian method document.
 * @record
 */
export function PLOptions() { }
if (false) {
    /** @type {?|undefined} */
    PLOptions.prototype.persianDigits;
    /** @type {?|undefined} */
    PLOptions.prototype.enDigits;
    /** @type {?|undefined} */
    PLOptions.prototype.symbols;
    /** @type {?|undefined} */
    PLOptions.prototype.whitespaces;
}
/**
 * This service brings validation of persian texts to the program and let you convert some not-persian letters with persian ones.
 *
 */
export class PersianLetterService {
    /**
     * According to the options values, returns a RegExp object. The regex pattern of it contains regex of finding each of
     * elements those specified in the options object plus persian letters.
     * @private
     * @param {?} options
     * @return {?} a RegExp object that can use in searching a string for special characters (persian letters and others specified in the options)
     */
    static _stringValidationRegex(options) {
        /** @type {?} */
        let result = '';
        if (options.enDigits) {
            result += '0-9';
        }
        if (options.symbols) {
            result += PersianLetterService.SYMBOLS_PATTERN;
        }
        if (options.whitespaces) {
            result += PersianLetterService.WHITESPACES_PATTERN;
        }
        if (options.persianDigits) {
            result += PersianNumberService.persianNumberPattern;
        }
        // language=JSRegexp
        return new RegExp(`[${result + PersianLetterService.PERSIAN_LETTERS_PATTERN}]`, 'g');
    }
    /**
     * This method gets regex of persian letters and other chars specified in the options and then splits the input value by that regex.
     *
     * If match result is null - there is no match - returns 0. otherwise returns length of the match array that shows number of matched
     * occurred in the input value.
     * @private
     * @param {?} value
     * @param {?} options
     * @return {?} a number greater equal to 0 representing number of matches occurred in the input value.
     */
    static _getMatchedPatternLength(value, options) {
        /** @type {?} */
        const matchResult = value.match(PersianLetterService._stringValidationRegex(options));
        return matchResult ? matchResult.length : 0;
    }
    /**
     * If input value contains any persian letter or is an empty string, returns true. otherwise returns false.
     * @param {?} value
     * @return {?}
     */
    containsPersian(value) {
        if (value === undefined || value === null) {
            return false;
        }
        // language=JSRegexp
        /** @type {?} */
        const persianRegex = new RegExp(`[${PersianLetterService.PERSIAN_LETTERS_PATTERN}]`);
        return value.trim() ? persianRegex.test(value) : true;
    }
    /**
     * Checks if input value is a persian text or not. If input value contains any letter that is not persian, the output will be false.
     * Result of validation on existence  of other characters controls by options parameter.
     * @param {?} value
     * @param {?=} options controlling validation result on existence  of other characters controls by options parameter. Fields:
     *
     *        persianDigits: if sets to true, validation result will be true if input value contains persian digits plus persian letters.
     *
     *
     *        enDigits: if sets to true, validation result will be true if input value contains english digits plus persian letters
     *
     *
     *        symbols: if sets to true, validation result will be true if input value contains specific symbols plus persian letters.
     *                 symbols list: ?$-/:؟!~"'^_-[]{}()%&*><;
     *
     *
     *        whitespaces: if sets to true, validation result will be true if input value contains white spaces plus persian letters
     *
     *
     * You can combine any number of options field together.
     * @return {?}
     */
    isPersian(value, options = {
        persianDigits: false,
        enDigits: false,
        symbols: true,
        whitespaces: true
    }) {
        if (value === undefined || value === null) {
            return false;
        }
        return value.length === PersianLetterService._getMatchedPatternLength(value, options);
    }
    /**
     * Converts arabic letters: ي and ك to persian corresponding letters.
     * @param {?} value
     * @return {?}
     */
    toPersian(value) {
        return value.replace(/ي/g, 'ی').replace(/ك/g, 'ک');
    }
}
PersianLetterService.PERSIAN_LETTERS_PATTERN = '\u06A9\u06AF\u06C0\u06CC\u060C\u062A\u062B\u062C\u062D\u062E\u062F\u063A\u064A\u064B\u064C' +
    '\u064D\u064E\u064F\u067E\u0670\u0686\u0698\u200C\u0621-\u0629\u0630-\u0639\u0641-\u0654';
PersianLetterService.SYMBOLS_PATTERN = '؟$-/:-?،{-~!"^_`\\[\\]';
PersianLetterService.WHITESPACES_PATTERN = '\\s';
PersianLetterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ PersianLetterService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function PersianLetterService_Factory() { return new PersianLetterService(); }, token: PersianLetterService, providedIn: "root" });
if (false) {
    /** @type {?} */
    PersianLetterService.PERSIAN_LETTERS_PATTERN;
    /**
     * @type {?}
     * @private
     */
    PersianLetterService.SYMBOLS_PATTERN;
    /** @type {?} */
    PersianLetterService.WHITESPACES_PATTERN;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyc2lhbi1sZXR0ZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1wZXJzaWFuLyIsInNvdXJjZXMiOlsibGliL1NlcnZpY2VzL3BlcnNpYW4tbGV0dGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7Ozs7OztBQUs5RCwrQkFLQzs7O0lBSkMsa0NBQXdCOztJQUN4Qiw2QkFBbUI7O0lBQ25CLDRCQUFrQjs7SUFDbEIsZ0NBQXNCOztBQU14Qjs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sb0JBQW9COzs7Ozs7OztJQWF2QixNQUFNLENBQUMsc0JBQXNCLENBQUMsT0FBa0I7O1lBQ2xELE1BQU0sR0FBRyxFQUFFO1FBQ2YsSUFBSSxPQUFPLENBQUMsUUFBUSxFQUFFO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQztTQUFFO1FBQzFDLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtZQUFFLE1BQU0sSUFBSSxvQkFBb0IsQ0FBQyxlQUFlLENBQUM7U0FBRTtRQUN4RSxJQUFJLE9BQU8sQ0FBQyxXQUFXLEVBQUU7WUFBRSxNQUFNLElBQUksb0JBQW9CLENBQUMsbUJBQW1CLENBQUM7U0FBRTtRQUNoRixJQUFJLE9BQU8sQ0FBQyxhQUFhLEVBQUU7WUFBRSxNQUFNLElBQUksb0JBQW9CLENBQUMsb0JBQW9CLENBQUM7U0FBRTtRQUNuRixvQkFBb0I7UUFDcEIsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLE1BQU0sR0FBRyxvQkFBb0IsQ0FBQyx1QkFBdUIsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZGLENBQUM7Ozs7Ozs7Ozs7O0lBV08sTUFBTSxDQUFDLHdCQUF3QixDQUFDLEtBQWEsRUFBRSxPQUFrQjs7Y0FDakUsV0FBVyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDckYsT0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QyxDQUFDOzs7Ozs7SUFNRCxlQUFlLENBQUMsS0FBYTtRQUMzQixJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxLQUFLLElBQUksRUFBRTtZQUFFLE9BQU8sS0FBSyxDQUFDO1NBQUU7OztjQUV0RCxZQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxvQkFBb0IsQ0FBQyx1QkFBdUIsR0FBRyxDQUFDO1FBQ3BGLE9BQU8sS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDeEQsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1QkQsU0FBUyxDQUFDLEtBQWEsRUFBRSxVQUFxQjtRQUNFLGFBQWEsRUFBRSxLQUFLO1FBQ3BCLFFBQVEsRUFBRSxLQUFLO1FBQ2YsT0FBTyxFQUFFLElBQUk7UUFDYixXQUFXLEVBQUUsSUFBSTtLQUFDO1FBQ2hFLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO1lBQUUsT0FBTyxLQUFLLENBQUM7U0FBRTtRQUM1RCxPQUFPLEtBQUssQ0FBQyxNQUFNLEtBQUssb0JBQW9CLENBQUMsd0JBQXdCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3hGLENBQUM7Ozs7OztJQU1ELFNBQVMsQ0FBQyxLQUFhO1FBQ3JCLE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNyRCxDQUFDOztBQWxGTSw0Q0FBdUIsR0FBRyw0RkFBNEY7SUFDeEYseUZBQXlGLENBQUM7QUFDaEgsb0NBQWUsR0FBRyx3QkFBd0IsQ0FBQztBQUNuRCx3Q0FBbUIsR0FBRyxLQUFLLENBQUM7O1lBWnBDLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7Ozs7SUFPQyw2Q0FDK0g7Ozs7O0lBQy9ILHFDQUEwRDs7SUFDMUQseUNBQW1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtQZXJzaWFuU2VydmljZX0gZnJvbSAnLi9wZXJzaWFuLXNlcnZpY2UnO1xuaW1wb3J0IHtQZXJzaWFuTnVtYmVyU2VydmljZX0gZnJvbSAnLi9wZXJzaWFuLW51bWJlci5zZXJ2aWNlJztcblxuLyoqXG4gKiBpc1BlcnNpYW4gb3B0aW9ucyBwYXJhbWV0ZXIgb2JqZWN0IHNob3VsZCBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2UuIEZpZWxkcyBkZXNjcmlwdGlvbnMgYXJlIGluIHRoZSBpc1BlcnNpYW4gbWV0aG9kIGRvY3VtZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBMT3B0aW9ucyB7XG4gIHBlcnNpYW5EaWdpdHM/OiBib29sZWFuO1xuICBlbkRpZ2l0cz86IGJvb2xlYW47XG4gIHN5bWJvbHM/OiBib29sZWFuO1xuICB3aGl0ZXNwYWNlcz86IGJvb2xlYW47XG59XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuLyoqXG4gKiBUaGlzIHNlcnZpY2UgYnJpbmdzIHZhbGlkYXRpb24gb2YgcGVyc2lhbiB0ZXh0cyB0byB0aGUgcHJvZ3JhbSBhbmQgbGV0IHlvdSBjb252ZXJ0IHNvbWUgbm90LXBlcnNpYW4gbGV0dGVycyB3aXRoIHBlcnNpYW4gb25lcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQZXJzaWFuTGV0dGVyU2VydmljZSBpbXBsZW1lbnRzIFBlcnNpYW5TZXJ2aWNlIHtcblxuICBzdGF0aWMgUEVSU0lBTl9MRVRURVJTX1BBVFRFUk4gPSAnXFx1MDZBOVxcdTA2QUZcXHUwNkMwXFx1MDZDQ1xcdTA2MENcXHUwNjJBXFx1MDYyQlxcdTA2MkNcXHUwNjJEXFx1MDYyRVxcdTA2MkZcXHUwNjNBXFx1MDY0QVxcdTA2NEJcXHUwNjRDJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFx1MDY0RFxcdTA2NEVcXHUwNjRGXFx1MDY3RVxcdTA2NzBcXHUwNjg2XFx1MDY5OFxcdTIwMENcXHUwNjIxLVxcdTA2MjlcXHUwNjMwLVxcdTA2MzlcXHUwNjQxLVxcdTA2NTQnO1xuICBwcml2YXRlIHN0YXRpYyBTWU1CT0xTX1BBVFRFUk4gPSAn2J8kLS86LT/YjHstfiFcIl5fYFxcXFxbXFxcXF0nO1xuICBzdGF0aWMgV0hJVEVTUEFDRVNfUEFUVEVSTiA9ICdcXFxccyc7XG5cbiAgLyoqXG4gICAqIEFjY29yZGluZyB0byB0aGUgb3B0aW9ucyB2YWx1ZXMsIHJldHVybnMgYSBSZWdFeHAgb2JqZWN0LiBUaGUgcmVnZXggcGF0dGVybiBvZiBpdCBjb250YWlucyByZWdleCBvZiBmaW5kaW5nIGVhY2ggb2ZcbiAgICogZWxlbWVudHMgdGhvc2Ugc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zIG9iamVjdCBwbHVzIHBlcnNpYW4gbGV0dGVycy5cbiAgICogQHJldHVybiBhIFJlZ0V4cCBvYmplY3QgdGhhdCBjYW4gdXNlIGluIHNlYXJjaGluZyBhIHN0cmluZyBmb3Igc3BlY2lhbCBjaGFyYWN0ZXJzIChwZXJzaWFuIGxldHRlcnMgYW5kIG90aGVycyBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMpXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfc3RyaW5nVmFsaWRhdGlvblJlZ2V4KG9wdGlvbnM6IFBMT3B0aW9ucyk6IFJlZ0V4cCB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGlmIChvcHRpb25zLmVuRGlnaXRzKSB7IHJlc3VsdCArPSAnMC05JzsgfVxuICAgIGlmIChvcHRpb25zLnN5bWJvbHMpIHsgcmVzdWx0ICs9IFBlcnNpYW5MZXR0ZXJTZXJ2aWNlLlNZTUJPTFNfUEFUVEVSTjsgfVxuICAgIGlmIChvcHRpb25zLndoaXRlc3BhY2VzKSB7IHJlc3VsdCArPSBQZXJzaWFuTGV0dGVyU2VydmljZS5XSElURVNQQUNFU19QQVRURVJOOyB9XG4gICAgaWYgKG9wdGlvbnMucGVyc2lhbkRpZ2l0cykgeyByZXN1bHQgKz0gUGVyc2lhbk51bWJlclNlcnZpY2UucGVyc2lhbk51bWJlclBhdHRlcm47IH1cbiAgICAvLyBsYW5ndWFnZT1KU1JlZ2V4cFxuICAgIHJldHVybiBuZXcgUmVnRXhwKGBbJHtyZXN1bHQgKyBQZXJzaWFuTGV0dGVyU2VydmljZS5QRVJTSUFOX0xFVFRFUlNfUEFUVEVSTn1dYCwgJ2cnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBnZXRzIHJlZ2V4IG9mIHBlcnNpYW4gbGV0dGVycyBhbmQgb3RoZXIgY2hhcnMgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zIGFuZCB0aGVuIHNwbGl0cyB0aGUgaW5wdXQgdmFsdWUgYnkgdGhhdCByZWdleC5cbiAgICpcbiAgICogSWYgbWF0Y2ggcmVzdWx0IGlzIG51bGwgLSB0aGVyZSBpcyBubyBtYXRjaCAtIHJldHVybnMgMC4gb3RoZXJ3aXNlIHJldHVybnMgbGVuZ3RoIG9mIHRoZSBtYXRjaCBhcnJheSB0aGF0IHNob3dzIG51bWJlciBvZiBtYXRjaGVkXG4gICAqIG9jY3VycmVkIGluIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm4gYSBudW1iZXIgZ3JlYXRlciBlcXVhbCB0byAwIHJlcHJlc2VudGluZyBudW1iZXIgb2YgbWF0Y2hlcyBvY2N1cnJlZCBpbiB0aGUgaW5wdXQgdmFsdWUuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfZ2V0TWF0Y2hlZFBhdHRlcm5MZW5ndGgodmFsdWU6IHN0cmluZywgb3B0aW9uczogUExPcHRpb25zKTogbnVtYmVyIHtcbiAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHZhbHVlLm1hdGNoKFBlcnNpYW5MZXR0ZXJTZXJ2aWNlLl9zdHJpbmdWYWxpZGF0aW9uUmVnZXgob3B0aW9ucykpO1xuICAgIHJldHVybiBtYXRjaFJlc3VsdCA/IG1hdGNoUmVzdWx0Lmxlbmd0aCA6IDA7XG4gIH1cblxuICAvKipcbiAgICogSWYgaW5wdXQgdmFsdWUgY29udGFpbnMgYW55IHBlcnNpYW4gbGV0dGVyIG9yIGlzIGFuIGVtcHR5IHN0cmluZywgcmV0dXJucyB0cnVlLiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBjb250YWluc1BlcnNpYW4odmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIGxhbmd1YWdlPUpTUmVnZXhwXG4gICAgY29uc3QgcGVyc2lhblJlZ2V4ID0gbmV3IFJlZ0V4cChgWyR7UGVyc2lhbkxldHRlclNlcnZpY2UuUEVSU0lBTl9MRVRURVJTX1BBVFRFUk59XWApO1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgPyBwZXJzaWFuUmVnZXgudGVzdCh2YWx1ZSkgOiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBpbnB1dCB2YWx1ZSBpcyBhIHBlcnNpYW4gdGV4dCBvciBub3QuIElmIGlucHV0IHZhbHVlIGNvbnRhaW5zIGFueSBsZXR0ZXIgdGhhdCBpcyBub3QgcGVyc2lhbiwgdGhlIG91dHB1dCB3aWxsIGJlIGZhbHNlLlxuICAgKiBSZXN1bHQgb2YgdmFsaWRhdGlvbiBvbiBleGlzdGVuY2UgIG9mIG90aGVyIGNoYXJhY3RlcnMgY29udHJvbHMgYnkgb3B0aW9ucyBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBjb250cm9sbGluZyB2YWxpZGF0aW9uIHJlc3VsdCBvbiBleGlzdGVuY2UgIG9mIG90aGVyIGNoYXJhY3RlcnMgY29udHJvbHMgYnkgb3B0aW9ucyBwYXJhbWV0ZXIuIEZpZWxkczpcbiAgICpcbiAgICogICAgICAgIHBlcnNpYW5EaWdpdHM6IGlmIHNldHMgdG8gdHJ1ZSwgdmFsaWRhdGlvbiByZXN1bHQgd2lsbCBiZSB0cnVlIGlmIGlucHV0IHZhbHVlIGNvbnRhaW5zIHBlcnNpYW4gZGlnaXRzIHBsdXMgcGVyc2lhbiBsZXR0ZXJzLlxuICAgKlxuICAgKlxuICAgKiAgICAgICAgZW5EaWdpdHM6IGlmIHNldHMgdG8gdHJ1ZSwgdmFsaWRhdGlvbiByZXN1bHQgd2lsbCBiZSB0cnVlIGlmIGlucHV0IHZhbHVlIGNvbnRhaW5zIGVuZ2xpc2ggZGlnaXRzIHBsdXMgcGVyc2lhbiBsZXR0ZXJzXG4gICAqXG4gICAqXG4gICAqICAgICAgICBzeW1ib2xzOiBpZiBzZXRzIHRvIHRydWUsIHZhbGlkYXRpb24gcmVzdWx0IHdpbGwgYmUgdHJ1ZSBpZiBpbnB1dCB2YWx1ZSBjb250YWlucyBzcGVjaWZpYyBzeW1ib2xzIHBsdXMgcGVyc2lhbiBsZXR0ZXJzLlxuICAgKiAgICAgICAgICAgICAgICAgc3ltYm9scyBsaXN0OiA/JC0vOtifIX5cIideXy1bXXt9KCklJio+PDtcbiAgICpcbiAgICpcbiAgICogICAgICAgIHdoaXRlc3BhY2VzOiBpZiBzZXRzIHRvIHRydWUsIHZhbGlkYXRpb24gcmVzdWx0IHdpbGwgYmUgdHJ1ZSBpZiBpbnB1dCB2YWx1ZSBjb250YWlucyB3aGl0ZSBzcGFjZXMgcGx1cyBwZXJzaWFuIGxldHRlcnNcbiAgICpcbiAgICpcbiAgICogWW91IGNhbiBjb21iaW5lIGFueSBudW1iZXIgb2Ygb3B0aW9ucyBmaWVsZCB0b2dldGhlci5cbiAgICovXG4gIGlzUGVyc2lhbih2YWx1ZTogc3RyaW5nLCBvcHRpb25zOiBQTE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpYW5EaWdpdHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbkRpZ2l0czogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VzOiB0cnVlfSk6IGJvb2xlYW4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IFBlcnNpYW5MZXR0ZXJTZXJ2aWNlLl9nZXRNYXRjaGVkUGF0dGVybkxlbmd0aCh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYXJhYmljIGxldHRlcnM6INmKIGFuZCDZgyB0byBwZXJzaWFuIGNvcnJlc3BvbmRpbmcgbGV0dGVycy5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICB0b1BlcnNpYW4odmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL9mKL2csICfbjCcpLnJlcGxhY2UoL9mDL2csICfaqScpO1xuICB9XG5cbn1cbiJdfQ==