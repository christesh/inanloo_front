/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Pipe } from '@angular/core';
import { JDate } from '../JDate/jdate';
/** @enum {string} */
var FromatNames = {
    'short': 'yy/m/d h:M t',
    'shortDate': 'yy/m/d h:M t',
    'medium': 'd mmm yyyy، h:M t',
    'mediumDate': 'd mmm yyyy، h:M t',
    'long': 'd mmm yyyy، h:M:S T',
    'longDate': 'd mmm yyyy، h:M:S T',
    'shortTime': 'h:M t',
    'mediumTime': 'h:M:S t',
    'longTime': 'h:M:S.l T',
};
/**
 * Formats JDate objects or convert Date objects (or any instance of classes those implement that interface) to a `JDate` object and format
 * that according to the given format.
 *
 * The result of this pipe is not reevaluated when the input is mutated. To avoid the need to reformat the date on every change-detection
 * cycle, treat the date as an immutable object and change the reference when the pipe needs to run again.
 *
 * You can pass a format pattern string like [JDate format method]{\@link https://alihoseiny.github.io/ngx-persian/classes/JDate.html#format}
 *
 * Also you can use pre-defined format names described below:
 *
 *        'short': equivalent to yy/m/d h:M t {\@example '97/2/23 12:12 ب.ظ'}
 *
 *        'shortDate': same as short
 *
 *        'medium': equivalent to 'd mmm yyyy، h:M t' {\@example '23 اردیبهشت 1397، 12:12 ب.ظ'}
 *
 *        'mediumDate': same as medium
 *
 *        'long': equivalent to 'd mmm yyyy، h:M:S T' {\@example '23 اردیبهشت 1397، 12:12:30 بعد از ظهر'}
 *
 *        'longDate': same as long
 *
 *        'shortTime': equivalent to 'h:M t' {\@example '12:12 ب.ظ'}
 *
 *        'mediumTime': equivalent to 'h:M:S t' {\@example '12:12:30 ب.ظ'}
 *
 *        'longTime': equivalent to 'h:M:S.l T' {\@example '12:12:30.300 بعد از ظهر'}
 *
 *  Default format is `medium`.
 */
var JdatePipe = /** @class */ (function () {
    function JdatePipe() {
    }
    /**
     * Checks if `formatName` is in the `FromatNames` enum. If it is, returns related format string. Else returns `formatName` string
     * without any change.
     * @param formatName format name or format pattern string
     * @return formatting pattern string
     */
    /**
     * Checks if `formatName` is in the `FromatNames` enum. If it is, returns related format string. Else returns `formatName` string
     * without any change.
     * @private
     * @param {?} formatName format name or format pattern string
     * @return {?} formatting pattern string
     */
    JdatePipe.convertNameToFormat = /**
     * Checks if `formatName` is in the `FromatNames` enum. If it is, returns related format string. Else returns `formatName` string
     * without any change.
     * @private
     * @param {?} formatName format name or format pattern string
     * @return {?} formatting pattern string
     */
    function (formatName) {
        if (!FromatNames[formatName]) {
            return formatName;
        }
        return FromatNames[formatName];
    };
    /**
     * Formatting the date using `format` method of it with proper formatting pattern created from `format`
     * @param value a Jalali Date object or an instance of `Date` object or any class implementing that interface
     * @param format format name or format pattern string
     */
    /**
     * Formatting the date using `format` method of it with proper formatting pattern created from `format`
     * @param {?} value a Jalali Date object or an instance of `Date` object or any class implementing that interface
     * @param {?=} format format name or format pattern string
     * @return {?}
     */
    JdatePipe.prototype.transform = /**
     * Formatting the date using `format` method of it with proper formatting pattern created from `format`
     * @param {?} value a Jalali Date object or an instance of `Date` object or any class implementing that interface
     * @param {?=} format format name or format pattern string
     * @return {?}
     */
    function (value, format) {
        if (format === void 0) { format = 'mediumDate'; }
        if (!(value instanceof JDate)) {
            value = new JDate(value);
        }
        // @ts-ignore
        return value.format(JdatePipe.convertNameToFormat(format));
    };
    JdatePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'jdate'
                },] }
    ];
    return JdatePipe;
}());
export { JdatePipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiamRhdGUucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1wZXJzaWFuLyIsInNvdXJjZXMiOlsibGliL1BpcGVzL2pkYXRlLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQ3BELE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7O0lBTW5DLFNBQVUsY0FBYztJQUN4QixhQUFjLGNBQWM7SUFDNUIsVUFBVyxtQkFBbUI7SUFDOUIsY0FBZSxtQkFBbUI7SUFDbEMsUUFBUyxxQkFBcUI7SUFDOUIsWUFBYSxxQkFBcUI7SUFDbEMsYUFBYyxPQUFPO0lBQ3JCLGNBQWUsU0FBUztJQUN4QixZQUFhLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDMUI7SUFBQTtJQStCQSxDQUFDO0lBMUJDOzs7OztPQUtHOzs7Ozs7OztJQUNZLDZCQUFtQjs7Ozs7OztJQUFsQyxVQUFtQyxVQUFrQjtRQUNuRCxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzVCLE9BQU8sVUFBVSxDQUFBO1NBQ2xCO1FBQ0QsT0FBTyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7Ozs7Ozs7SUFDSCw2QkFBUzs7Ozs7O0lBQVQsVUFBVSxLQUFXLEVBQUUsTUFBNkI7UUFBN0IsdUJBQUEsRUFBQSxxQkFBNkI7UUFDbEQsSUFBSSxDQUFDLENBQUMsS0FBSyxZQUFZLEtBQUssQ0FBQyxFQUFFO1lBQzdCLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMxQjtRQUNELGFBQWE7UUFDYixPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDN0QsQ0FBQzs7Z0JBN0JGLElBQUksU0FBQztvQkFDSixJQUFJLEVBQUUsT0FBTztpQkFDZDs7SUE2QkQsZ0JBQUM7Q0FBQSxBQS9CRCxJQStCQztTQTVCWSxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtKRGF0ZX0gZnJvbSAnLi4vSkRhdGUvamRhdGUnO1xuXG4vKipcbiAqIFByZS1kZWZpbmVkIGZvcm1hdHMgZGF0ZSBmb3JtYXRzIHRob3NlIGNhbiB1c2UgZm9yIGZvcm1hdHRpbmcgSkRhdGUgb2JqZWN0cyB3aXRoIGpkYXRlIHBpcGUuXG4gKi9cbmVudW0gRnJvbWF0TmFtZXMge1xuICAnc2hvcnQnID0gJ3l5L20vZCBoOk0gdCcsXG4gICdzaG9ydERhdGUnID0gJ3l5L20vZCBoOk0gdCcsXG4gICdtZWRpdW0nID0gJ2QgbW1tIHl5eXnYjCBoOk0gdCcsXG4gICdtZWRpdW1EYXRlJyA9ICdkIG1tbSB5eXl52IwgaDpNIHQnLFxuICAnbG9uZycgPSAnZCBtbW0geXl5ediMIGg6TTpTIFQnLFxuICAnbG9uZ0RhdGUnID0gJ2QgbW1tIHl5eXnYjCBoOk06UyBUJyxcbiAgJ3Nob3J0VGltZScgPSAnaDpNIHQnLFxuICAnbWVkaXVtVGltZScgPSAnaDpNOlMgdCcsXG4gICdsb25nVGltZScgPSAnaDpNOlMubCBUJyxcbn1cblxuLyoqXG4gKiBGb3JtYXRzIEpEYXRlIG9iamVjdHMgb3IgY29udmVydCBEYXRlIG9iamVjdHMgKG9yIGFueSBpbnN0YW5jZSBvZiBjbGFzc2VzIHRob3NlIGltcGxlbWVudCB0aGF0IGludGVyZmFjZSkgdG8gYSBgSkRhdGVgIG9iamVjdCBhbmQgZm9ybWF0XG4gKiB0aGF0IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZm9ybWF0LlxuICpcbiAqIFRoZSByZXN1bHQgb2YgdGhpcyBwaXBlIGlzIG5vdCByZWV2YWx1YXRlZCB3aGVuIHRoZSBpbnB1dCBpcyBtdXRhdGVkLiBUbyBhdm9pZCB0aGUgbmVlZCB0byByZWZvcm1hdCB0aGUgZGF0ZSBvbiBldmVyeSBjaGFuZ2UtZGV0ZWN0aW9uXG4gKiBjeWNsZSwgdHJlYXQgdGhlIGRhdGUgYXMgYW4gaW1tdXRhYmxlIG9iamVjdCBhbmQgY2hhbmdlIHRoZSByZWZlcmVuY2Ugd2hlbiB0aGUgcGlwZSBuZWVkcyB0byBydW4gYWdhaW4uXG4gKlxuICogWW91IGNhbiBwYXNzIGEgZm9ybWF0IHBhdHRlcm4gc3RyaW5nIGxpa2UgW0pEYXRlIGZvcm1hdCBtZXRob2Rde0BsaW5rIGh0dHBzOi8vYWxpaG9zZWlueS5naXRodWIuaW8vbmd4LXBlcnNpYW4vY2xhc3Nlcy9KRGF0ZS5odG1sI2Zvcm1hdH1cbiAqXG4gKiBBbHNvIHlvdSBjYW4gdXNlIHByZS1kZWZpbmVkIGZvcm1hdCBuYW1lcyBkZXNjcmliZWQgYmVsb3c6XG4gKlxuICogICAgICAgICdzaG9ydCc6IGVxdWl2YWxlbnQgdG8geXkvbS9kIGg6TSB0IHtAZXhhbXBsZSAnOTcvMi8yMyAxMjoxMiDYqC7YuCd9XG4gKlxuICogICAgICAgICdzaG9ydERhdGUnOiBzYW1lIGFzIHNob3J0XG4gKlxuICogICAgICAgICdtZWRpdW0nOiBlcXVpdmFsZW50IHRvICdkIG1tbSB5eXl52IwgaDpNIHQnIHtAZXhhbXBsZSAnMjMg2KfYsdiv24zYqNmH2LTYqiAxMzk32IwgMTI6MTIg2Kgu2LgnfVxuICpcbiAqICAgICAgICAnbWVkaXVtRGF0ZSc6IHNhbWUgYXMgbWVkaXVtXG4gKlxuICogICAgICAgICdsb25nJzogZXF1aXZhbGVudCB0byAnZCBtbW0geXl5ediMIGg6TTpTIFQnIHtAZXhhbXBsZSAnMjMg2KfYsdiv24zYqNmH2LTYqiAxMzk32IwgMTI6MTI6MzAg2KjYudivINin2LIg2LjZh9ixJ31cbiAqXG4gKiAgICAgICAgJ2xvbmdEYXRlJzogc2FtZSBhcyBsb25nXG4gKlxuICogICAgICAgICdzaG9ydFRpbWUnOiBlcXVpdmFsZW50IHRvICdoOk0gdCcge0BleGFtcGxlICcxMjoxMiDYqC7YuCd9XG4gKlxuICogICAgICAgICdtZWRpdW1UaW1lJzogZXF1aXZhbGVudCB0byAnaDpNOlMgdCcge0BleGFtcGxlICcxMjoxMjozMCDYqC7YuCd9XG4gKlxuICogICAgICAgICdsb25nVGltZSc6IGVxdWl2YWxlbnQgdG8gJ2g6TTpTLmwgVCcge0BleGFtcGxlICcxMjoxMjozMC4zMDAg2KjYudivINin2LIg2LjZh9ixJ31cbiAqXG4gKiAgRGVmYXVsdCBmb3JtYXQgaXMgYG1lZGl1bWAuXG4gKi9cbkBQaXBlKHtcbiAgbmFtZTogJ2pkYXRlJ1xufSlcbmV4cG9ydCBjbGFzcyBKZGF0ZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBmb3JtYXROYW1lYCBpcyBpbiB0aGUgYEZyb21hdE5hbWVzYCBlbnVtLiBJZiBpdCBpcywgcmV0dXJucyByZWxhdGVkIGZvcm1hdCBzdHJpbmcuIEVsc2UgcmV0dXJucyBgZm9ybWF0TmFtZWAgc3RyaW5nXG4gICAqIHdpdGhvdXQgYW55IGNoYW5nZS5cbiAgICogQHBhcmFtIGZvcm1hdE5hbWUgZm9ybWF0IG5hbWUgb3IgZm9ybWF0IHBhdHRlcm4gc3RyaW5nXG4gICAqIEByZXR1cm4gZm9ybWF0dGluZyBwYXR0ZXJuIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgY29udmVydE5hbWVUb0Zvcm1hdChmb3JtYXROYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghRnJvbWF0TmFtZXNbZm9ybWF0TmFtZV0pIHtcbiAgICAgIHJldHVybiBmb3JtYXROYW1lXG4gICAgfVxuICAgIHJldHVybiBGcm9tYXROYW1lc1tmb3JtYXROYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXR0aW5nIHRoZSBkYXRlIHVzaW5nIGBmb3JtYXRgIG1ldGhvZCBvZiBpdCB3aXRoIHByb3BlciBmb3JtYXR0aW5nIHBhdHRlcm4gY3JlYXRlZCBmcm9tIGBmb3JtYXRgXG4gICAqIEBwYXJhbSB2YWx1ZSBhIEphbGFsaSBEYXRlIG9iamVjdCBvciBhbiBpbnN0YW5jZSBvZiBgRGF0ZWAgb2JqZWN0IG9yIGFueSBjbGFzcyBpbXBsZW1lbnRpbmcgdGhhdCBpbnRlcmZhY2VcbiAgICogQHBhcmFtIGZvcm1hdCBmb3JtYXQgbmFtZSBvciBmb3JtYXQgcGF0dGVybiBzdHJpbmdcbiAgICovXG4gIHRyYW5zZm9ybSh2YWx1ZTogRGF0ZSwgZm9ybWF0OiBzdHJpbmcgPSAnbWVkaXVtRGF0ZScpOiBzdHJpbmcge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgSkRhdGUpKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBKRGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdmFsdWUuZm9ybWF0KEpkYXRlUGlwZS5jb252ZXJ0TmFtZVRvRm9ybWF0KGZvcm1hdCkpO1xuICB9XG5cbn1cbiJdfQ==