/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { div, mod } from './ArithmeticUtils';
import { InvalidJalaliDateError } from './InvalidJalaliDate.error';
import * as i0 from "@angular/core";
/**
 * Methods of this Service doing validation stuff on a Jalali date. You can use this Service using DI in all around of your app for
 * validating Jalali dates without needing to convert them to the Georgian Date.
 */
var JalaliDateValidatorService = /** @class */ (function () {
    function JalaliDateValidatorService() {
    }
    /**
     * Returns number of days in a given month counting from 1.
     * @param jYear full jalali year like 1397
     * @param jMonth number of month from 0 for Farvardin to 11 for Esfand.
     */
    /**
     * Returns number of days in a given month counting from 1.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth number of month from 0 for Farvardin to 11 for Esfand.
     * @return {?}
     */
    JalaliDateValidatorService.prototype.jMonthLength = /**
     * Returns number of days in a given month counting from 1.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth number of month from 0 for Farvardin to 11 for Esfand.
     * @return {?}
     */
    function (jYear, jMonth) {
        if (jMonth < 6) {
            return 31;
        }
        if (jMonth < 11 || this.isJYearLeap(jYear)) {
            return 30;
        }
        return 29;
    };
    /**
     * Calculates the number of the leap years in jalali Calendar.
     * @param targetJYear should be full year like: 1397 and should be between -61 to 3177.
     *
     * [Implementation in source code]{@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L71}
     */
    /**
     * Calculates the number of the leap years in jalali Calendar.
     * @param {?} targetJYear should be full year like: 1397 and should be between -61 to 3177.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L71}
     * @return {?}
     */
    JalaliDateValidatorService.prototype.numOfJLeapYears = /**
     * Calculates the number of the leap years in jalali Calendar.
     * @param {?} targetJYear should be full year like: 1397 and should be between -61 to 3177.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L71}
     * @return {?}
     */
    function (targetJYear) {
        // Jalali years starting the 33-year rule.
        /** @type {?} */
        var breaks = [
            -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210,
            1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178,
        ];
        /** @type {?} */
        var breaksLength = breaks.length;
        /** @type {?} */
        var jp = breaks[0];
        /** @type {?} */
        var jump;
        /** @type {?} */
        var leapJ = -14;
        if (!this.isValidJYear(targetJYear)) {
            throw new InvalidJalaliDateError();
        }
        // Find the limiting years for the Jalali year jy.
        for (var i = 1; i < breaksLength; i += 1) {
            /** @type {?} */
            var jm = breaks[i];
            jump = jm - jp;
            if (targetJYear < jm) {
                break;
            }
            leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
            jp = jm;
        }
        /** @type {?} */
        var n = targetJYear - jp;
        // Find the number of leap years from AD 621 to the beginning
        // of the current Jalali year in the Persian Calendar.
        leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
        if (mod(jump, 33) === 4 && jump - n === 4) {
            leapJ += 1;
        }
        return leapJ;
    };
    /**
     * If JYear is a leap year in jalali Calendar, return true. We using the fact that if a year is leap, number of leap years until that year
     * and the year after it is not equal.
     * @param jYear full jalali year like: 1397
     */
    /**
     * If JYear is a leap year in jalali Calendar, return true. We using the fact that if a year is leap, number of leap years until that year
     * and the year after it is not equal.
     * @param {?} jYear full jalali year like: 1397
     * @return {?}
     */
    JalaliDateValidatorService.prototype.isJYearLeap = /**
     * If JYear is a leap year in jalali Calendar, return true. We using the fact that if a year is leap, number of leap years until that year
     * and the year after it is not equal.
     * @param {?} jYear full jalali year like: 1397
     * @return {?}
     */
    function (jYear) {
        return this.numOfJLeapYears(jYear) !== this.numOfJLeapYears(jYear + 1);
    };
    /**
     * Checks if jalali year is in acceptable range or not.
     *
     * [Implementation in source code]{@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L27}
     * @param jYear full jalali year like 1397
     */
    /**
     * Checks if jalali year is in acceptable range or not.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L27}
     * @param {?} jYear full jalali year like 1397
     * @return {?}
     */
    JalaliDateValidatorService.prototype.isValidJYear = /**
     * Checks if jalali year is in acceptable range or not.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L27}
     * @param {?} jYear full jalali year like 1397
     * @return {?}
     */
    function (jYear) {
        return jYear >= JalaliDateValidatorService._minAcceptableYear && jYear <= JalaliDateValidatorService._maxAcceptableYear;
    };
    /**
     * Checks if jalali month is in valid range or not. In default, jMonth should start from zero.
     * If you want to start month number from one instead of zero, you should make startFromZero parameter to false.
     */
    /**
     * Checks if jalali month is in valid range or not. In default, jMonth should start from zero.
     * If you want to start month number from one instead of zero, you should make startFromZero parameter to false.
     * @param {?} jMonth
     * @param {?=} startFromZero
     * @return {?}
     */
    JalaliDateValidatorService.prototype.isValidJMonth = /**
     * Checks if jalali month is in valid range or not. In default, jMonth should start from zero.
     * If you want to start month number from one instead of zero, you should make startFromZero parameter to false.
     * @param {?} jMonth
     * @param {?=} startFromZero
     * @return {?}
     */
    function (jMonth, startFromZero) {
        if (startFromZero === void 0) { startFromZero = true; }
        /** @type {?} */
        var minMonthNumber = 0;
        /** @type {?} */
        var maxMonthNumber = 11;
        if (!startFromZero) {
            minMonthNumber++;
            maxMonthNumber++;
        }
        return jMonth >= minMonthNumber && jMonth <= maxMonthNumber;
    };
    /**
     * Checks if day number is in valid range according to the given year and month.
     * @param jYear full jalali year like 1397
     * @param jMonth month number starting from zero
     * @param jDay day number starting from one
     */
    /**
     * Checks if day number is in valid range according to the given year and month.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth month number starting from zero
     * @param {?} jDay day number starting from one
     * @return {?}
     */
    JalaliDateValidatorService.prototype.isValidJDay = /**
     * Checks if day number is in valid range according to the given year and month.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth month number starting from zero
     * @param {?} jDay day number starting from one
     * @return {?}
     */
    function (jYear, jMonth, jDay) {
        return jDay <= this.jMonthLength(jYear, jMonth) && jDay > 0;
    };
    /**
     * If Jalali date is not a valid Jalali date, return false. otherwise returns true.
     * @param jYear full year number like: 1397
     * @param jMonth starts from zero
     * @param jDay starts from one
     */
    /**
     * If Jalali date is not a valid Jalali date, return false. otherwise returns true.
     * @param {?} jYear full year number like: 1397
     * @param {?} jMonth starts from zero
     * @param {?} jDay starts from one
     * @return {?}
     */
    JalaliDateValidatorService.prototype.isValidJDate = /**
     * If Jalali date is not a valid Jalali date, return false. otherwise returns true.
     * @param {?} jYear full year number like: 1397
     * @param {?} jMonth starts from zero
     * @param {?} jDay starts from one
     * @return {?}
     */
    function (jYear, jMonth, jDay) {
        return this.isValidJYear(jYear) && this.isValidJMonth(jMonth) && this.isValidJDay(jYear, jMonth, jDay);
    };
    JalaliDateValidatorService._minAcceptableYear = -61;
    JalaliDateValidatorService._maxAcceptableYear = 3177;
    JalaliDateValidatorService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    JalaliDateValidatorService.ctorParameters = function () { return []; };
    /** @nocollapse */ JalaliDateValidatorService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function JalaliDateValidatorService_Factory() { return new JalaliDateValidatorService(); }, token: JalaliDateValidatorService, providedIn: "root" });
    return JalaliDateValidatorService;
}());
export { JalaliDateValidatorService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    JalaliDateValidatorService._minAcceptableYear;
    /**
     * @type {?}
     * @private
     */
    JalaliDateValidatorService._maxAcceptableYear;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiamFsYWxpLWRhdGUtdmFsaWRhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtcGVyc2lhbi8iLCJzb3VyY2VzIjpbImxpYi9KRGF0ZS9qYWxhbGktZGF0ZS12YWxpZGF0b3Iuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLDJCQUEyQixDQUFDOzs7Ozs7QUFPakU7SUFRRTtJQUFnQixDQUFDO0lBRWpCOzs7O09BSUc7Ozs7Ozs7SUFDSCxpREFBWTs7Ozs7O0lBQVosVUFBYSxLQUFhLEVBQUUsTUFBYztRQUN4QyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFBRSxPQUFPLEVBQUUsQ0FBQztTQUFFO1FBQzlCLElBQUksTUFBTSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQUUsT0FBTyxFQUFFLENBQUM7U0FBRTtRQUMxRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFHRDs7Ozs7T0FLRzs7Ozs7Ozs7SUFDSCxvREFBZTs7Ozs7OztJQUFmLFVBQWdCLFdBQW1COzs7WUFFM0IsTUFBTSxHQUFHO1lBQ2IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSTtZQUNyRCxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUk7U0FDckQ7O1lBRUssWUFBWSxHQUFHLE1BQU0sQ0FBQyxNQUFNOztZQUM5QixF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QUFDLENBQUM7SUFDekcsQ0FBQztJQWhIYyw2Q0FBa0IsR0FBRyxDQUFDLEVBQUUsQ0FBQztJQUN6Qiw2Q0FBa0IsR0FBRyxJQUFJLENBQUM7O2dCQU4xQyxVQUFVLFNBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzs7OztxQ0FYRDtDQStIQyxBQXRIRCxJQXNIQztTQW5IWSwwQkFBMEI7Ozs7OztJQUVyQyw4Q0FBd0M7Ozs7O0lBQ3hDLDhDQUF5QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7ZGl2LCBtb2R9IGZyb20gJy4vQXJpdGhtZXRpY1V0aWxzJztcbmltcG9ydCB7SW52YWxpZEphbGFsaURhdGVFcnJvcn0gZnJvbSAnLi9JbnZhbGlkSmFsYWxpRGF0ZS5lcnJvcic7XG5cblxuLyoqXG4gKiBNZXRob2RzIG9mIHRoaXMgU2VydmljZSBkb2luZyB2YWxpZGF0aW9uIHN0dWZmIG9uIGEgSmFsYWxpIGRhdGUuIFlvdSBjYW4gdXNlIHRoaXMgU2VydmljZSB1c2luZyBESSBpbiBhbGwgYXJvdW5kIG9mIHlvdXIgYXBwIGZvclxuICogdmFsaWRhdGluZyBKYWxhbGkgZGF0ZXMgd2l0aG91dCBuZWVkaW5nIHRvIGNvbnZlcnQgdGhlbSB0byB0aGUgR2VvcmdpYW4gRGF0ZS5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgSmFsYWxpRGF0ZVZhbGlkYXRvclNlcnZpY2Uge1xuXG4gIHByaXZhdGUgc3RhdGljIF9taW5BY2NlcHRhYmxlWWVhciA9IC02MTtcbiAgcHJpdmF0ZSBzdGF0aWMgX21heEFjY2VwdGFibGVZZWFyID0gMzE3NztcblxuICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciBvZiBkYXlzIGluIGEgZ2l2ZW4gbW9udGggY291bnRpbmcgZnJvbSAxLlxuICAgKiBAcGFyYW0galllYXIgZnVsbCBqYWxhbGkgeWVhciBsaWtlIDEzOTdcbiAgICogQHBhcmFtIGpNb250aCBudW1iZXIgb2YgbW9udGggZnJvbSAwIGZvciBGYXJ2YXJkaW4gdG8gMTEgZm9yIEVzZmFuZC5cbiAgICovXG4gIGpNb250aExlbmd0aChqWWVhcjogbnVtYmVyLCBqTW9udGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGpNb250aCA8IDYpIHsgcmV0dXJuIDMxOyB9XG4gICAgaWYgKGpNb250aCA8IDExIHx8IHRoaXMuaXNKWWVhckxlYXAoalllYXIpKSB7IHJldHVybiAzMDsgfVxuICAgIHJldHVybiAyOTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiB0aGUgbGVhcCB5ZWFycyBpbiBqYWxhbGkgQ2FsZW5kYXIuXG4gICAqIEBwYXJhbSB0YXJnZXRKWWVhciBzaG91bGQgYmUgZnVsbCB5ZWFyIGxpa2U6IDEzOTcgYW5kIHNob3VsZCBiZSBiZXR3ZWVuIC02MSB0byAzMTc3LlxuICAgKlxuICAgKiBbSW1wbGVtZW50YXRpb24gaW4gc291cmNlIGNvZGVde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zaWphZC90cy1qYWxhYWxpL2Jsb2IvMjk2YTdjMmZhMTgxNmE1YmJiMGIxMWJiZTNlYjAzZWJjMTcwNTlmNi9zcmMvamFsYWFsaS50cyNMNzF9XG4gICAqL1xuICBudW1PZkpMZWFwWWVhcnModGFyZ2V0SlllYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgLy8gSmFsYWxpIHllYXJzIHN0YXJ0aW5nIHRoZSAzMy15ZWFyIHJ1bGUuXG4gICAgY29uc3QgYnJlYWtzID0gW1xuICAgICAgLTYxLCA5LCAzOCwgMTk5LCA0MjYsIDY4NiwgNzU2LCA4MTgsIDExMTEsIDExODEsIDEyMTAsXG4gICAgICAxNjM1LCAyMDYwLCAyMDk3LCAyMTkyLCAyMjYyLCAyMzI0LCAyMzk0LCAyNDU2LCAzMTc4LFxuICAgIF07XG5cbiAgICBjb25zdCBicmVha3NMZW5ndGggPSBicmVha3MubGVuZ3RoO1xuICAgIGxldCBqcCA9IGJyZWFrc1swXTtcbiAgICBsZXQganVtcDogbnVtYmVyO1xuICAgIGxldCBsZWFwSiA9IC0xNDtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkSlllYXIodGFyZ2V0SlllYXIpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEphbGFsaURhdGVFcnJvcigpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGxpbWl0aW5nIHllYXJzIGZvciB0aGUgSmFsYWxpIHllYXIgankuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBicmVha3NMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgam0gPSBicmVha3NbaV07XG4gICAgICBqdW1wID0gam0gLSBqcDtcbiAgICAgIGlmICh0YXJnZXRKWWVhciA8IGptKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGVhcEogPSBsZWFwSiArIGRpdihqdW1wLCAzMykgKiA4ICsgZGl2KG1vZChqdW1wLCAzMyksIDQpO1xuICAgICAganAgPSBqbTtcbiAgICB9XG4gICAgY29uc3QgbiA9IHRhcmdldEpZZWFyIC0ganA7XG5cbiAgICAvLyBGaW5kIHRoZSBudW1iZXIgb2YgbGVhcCB5ZWFycyBmcm9tIEFEIDYyMSB0byB0aGUgYmVnaW5uaW5nXG4gICAgLy8gb2YgdGhlIGN1cnJlbnQgSmFsYWxpIHllYXIgaW4gdGhlIFBlcnNpYW4gQ2FsZW5kYXIuXG4gICAgbGVhcEogPSBsZWFwSiArIGRpdihuLCAzMykgKiA4ICsgZGl2KG1vZChuLCAzMykgKyAzLCA0KTtcblxuICAgIGlmIChtb2QoanVtcCwgMzMpID09PSA0ICYmIGp1bXAgLSBuID09PSA0KSB7XG4gICAgICBsZWFwSiArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbGVhcEo7XG4gIH1cblxuICAvKipcbiAgICogSWYgSlllYXIgaXMgYSBsZWFwIHllYXIgaW4gamFsYWxpIENhbGVuZGFyLCByZXR1cm4gdHJ1ZS4gV2UgdXNpbmcgdGhlIGZhY3QgdGhhdCBpZiBhIHllYXIgaXMgbGVhcCwgbnVtYmVyIG9mIGxlYXAgeWVhcnMgdW50aWwgdGhhdCB5ZWFyXG4gICAqIGFuZCB0aGUgeWVhciBhZnRlciBpdCBpcyBub3QgZXF1YWwuXG4gICAqIEBwYXJhbSBqWWVhciBmdWxsIGphbGFsaSB5ZWFyIGxpa2U6IDEzOTdcbiAgICovXG4gIGlzSlllYXJMZWFwKGpZZWFyOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5udW1PZkpMZWFwWWVhcnMoalllYXIpICE9PSB0aGlzLm51bU9mSkxlYXBZZWFycyhqWWVhciArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBqYWxhbGkgeWVhciBpcyBpbiBhY2NlcHRhYmxlIHJhbmdlIG9yIG5vdC5cbiAgICpcbiAgICogW0ltcGxlbWVudGF0aW9uIGluIHNvdXJjZSBjb2RlXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2lqYWQvdHMtamFsYWFsaS9ibG9iLzI5NmE3YzJmYTE4MTZhNWJiYjBiMTFiYmUzZWIwM2ViYzE3MDU5ZjYvc3JjL2phbGFhbGkudHMjTDI3fVxuICAgKiBAcGFyYW0galllYXIgZnVsbCBqYWxhbGkgeWVhciBsaWtlIDEzOTdcbiAgICovXG4gIGlzVmFsaWRKWWVhcihqWWVhcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGpZZWFyID49IEphbGFsaURhdGVWYWxpZGF0b3JTZXJ2aWNlLl9taW5BY2NlcHRhYmxlWWVhciAmJiBqWWVhciA8PSBKYWxhbGlEYXRlVmFsaWRhdG9yU2VydmljZS5fbWF4QWNjZXB0YWJsZVllYXI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGphbGFsaSBtb250aCBpcyBpbiB2YWxpZCByYW5nZSBvciBub3QuIEluIGRlZmF1bHQsIGpNb250aCBzaG91bGQgc3RhcnQgZnJvbSB6ZXJvLlxuICAgKiBJZiB5b3Ugd2FudCB0byBzdGFydCBtb250aCBudW1iZXIgZnJvbSBvbmUgaW5zdGVhZCBvZiB6ZXJvLCB5b3Ugc2hvdWxkIG1ha2Ugc3RhcnRGcm9tWmVybyBwYXJhbWV0ZXIgdG8gZmFsc2UuXG4gICAqL1xuICBpc1ZhbGlkSk1vbnRoKGpNb250aDogbnVtYmVyLCBzdGFydEZyb21aZXJvOiBib29sZWFuID0gdHJ1ZSk6IGJvb2xlYW4ge1xuICAgIGxldCBtaW5Nb250aE51bWJlciA9IDA7XG4gICAgbGV0IG1heE1vbnRoTnVtYmVyID0gMTE7XG4gICAgaWYgKCFzdGFydEZyb21aZXJvKSB7XG4gICAgICBtaW5Nb250aE51bWJlcisrO1xuICAgICAgbWF4TW9udGhOdW1iZXIrKztcbiAgICB9XG4gICAgcmV0dXJuIGpNb250aCA+PSBtaW5Nb250aE51bWJlciAmJiBqTW9udGggPD0gbWF4TW9udGhOdW1iZXI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGRheSBudW1iZXIgaXMgaW4gdmFsaWQgcmFuZ2UgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB5ZWFyIGFuZCBtb250aC5cbiAgICogQHBhcmFtIGpZZWFyIGZ1bGwgamFsYWxpIHllYXIgbGlrZSAxMzk3XG4gICAqIEBwYXJhbSBqTW9udGggbW9udGggbnVtYmVyIHN0YXJ0aW5nIGZyb20gemVyb1xuICAgKiBAcGFyYW0gakRheSBkYXkgbnVtYmVyIHN0YXJ0aW5nIGZyb20gb25lXG4gICAqL1xuICBpc1ZhbGlkSkRheShqWWVhcjogbnVtYmVyLCBqTW9udGg6IG51bWJlciwgakRheTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGpEYXkgPD0gdGhpcy5qTW9udGhMZW5ndGgoalllYXIsIGpNb250aCkgJiYgakRheSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogSWYgSmFsYWxpIGRhdGUgaXMgbm90IGEgdmFsaWQgSmFsYWxpIGRhdGUsIHJldHVybiBmYWxzZS4gb3RoZXJ3aXNlIHJldHVybnMgdHJ1ZS5cbiAgICogQHBhcmFtIGpZZWFyIGZ1bGwgeWVhciBudW1iZXIgbGlrZTogMTM5N1xuICAgKiBAcGFyYW0gak1vbnRoIHN0YXJ0cyBmcm9tIHplcm9cbiAgICogQHBhcmFtIGpEYXkgc3RhcnRzIGZyb20gb25lXG4gICAqL1xuICBpc1ZhbGlkSkRhdGUoalllYXI6IG51bWJlciwgak1vbnRoOiBudW1iZXIsIGpEYXk6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRKWWVhcihqWWVhcikgJiYgdGhpcy5pc1ZhbGlkSk1vbnRoKGpNb250aCkgJiYgdGhpcy5pc1ZhbGlkSkRheShqWWVhciwgak1vbnRoLCBqRGF5KTtcbiAgfVxufVxuIl19