import { Injectable, ɵɵdefineInjectable, Directive, Input, Pipe, ɵɵinject, NgModule } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { DecimalPipe } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This error will throw when input value of the service method is not a valid value.
 */
class InvalidServiceInputError extends Error {
    /**
     * @param {...?} params
     */
    constructor(...params) {
        super(...params);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        // @ts-ignore
        if (Error.captureStackTrace) {
            // @ts-ignore
            Error.captureStackTrace(this, InvalidServiceInputError);
        }
        this.message = 'Invalid value has been passed to the service.';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PersianNumberService {
    /**
     * Checks if input value contains any persian number or not.
     * @param {?} value
     * @return {?} true if input value contains any persian number. false otherwise.
     */
    containsPersian(value) {
        if (!value) {
            return false;
        }
        // language=JSRegexp
        /** @type {?} */
        const persianRegex = new RegExp(`[${PersianNumberService.persianNumberPattern}]`);
        return persianRegex.test(value);
    }
    /**
     * splits input value by persian letters and then returns length of matched array.
     * @private
     * @param {?} value
     * @return {?} 0 if input value has no persian letter, numbers of persian letters in the input value otherwise.
     */
    static _getMatchedPatternLength(value) {
        // language=JSRegexp
        /** @type {?} */
        const matchResult = value.match(new RegExp(`[${PersianNumberService.persianNumberPattern}]`, 'g'));
        return matchResult ? matchResult.length : 0;
    }
    /**
     * Checks if input value contains only persian letters.
     * @param {?} value
     * @return {?}
     */
    isPersian(value) {
        if (!value) {
            return false;
        }
        return value.length === PersianNumberService._getMatchedPatternLength(value);
    }
    /**
     * Converts arabic numbers to the persian ones.
     * @param {?} value
     * @return {?}
     */
    arabicToPersian(value) {
        return value.replace(/٤/g, PersianNumberService.persianNumbersTable[4])
            .replace(/٥/g, PersianNumberService.persianNumbersTable[5])
            .replace(/٦/g, PersianNumberService.persianNumbersTable[6]);
    }
    /**
     * Converts all arabic and english numbers to the persian numbers.
     * @param {?} value
     * @return {?}
     */
    toPersian(value) {
        if (value === undefined || value === null) {
            throw new InvalidServiceInputError();
        }
        value = value.toString();
        value = this.arabicToPersian(value);
        /** @type {?} */
        let regex;
        for (let i = 0; i < PersianNumberService.persianNumbersTable.length; i++) {
            // language=JSRegexp
            regex = new RegExp(`[${PersianNumberService.englishNumbersTable[i]}]`, 'g');
            value = value.replace(regex, PersianNumberService.persianNumbersTable[i]);
        }
        return value;
    }
    /**
     * Convert persian numbers in input value to the english numbers.
     * @param {?} value
     * @return {?}
     */
    toEnglish(value) {
        if (value === undefined || value === null) {
            throw new InvalidServiceInputError();
        }
        /** @type {?} */
        let regex;
        for (let i = 0; i < PersianNumberService.englishNumbersTable.length; i++) {
            // language=JSRegexp
            regex = new RegExp(`[${PersianNumberService.persianNumbersTable[i]}]`, 'g');
            value = value.replace(regex, PersianNumberService.englishNumbersTable[i]);
        }
        return value;
    }
}
PersianNumberService.persianNumberPattern = '\u06F0-\u06F9';
PersianNumberService.persianNumbersTable = ['\u06F0', '\u06F1', '\u06F2', '\u06F3', '\u06F4', '\u06F5', '\u06F6', '\u06F7', '\u06F8', '\u06F9'];
PersianNumberService.englishNumbersTable = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
PersianNumberService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ PersianNumberService.ngInjectableDef = ɵɵdefineInjectable({ factory: function PersianNumberService_Factory() { return new PersianNumberService(); }, token: PersianNumberService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This service brings validation of persian texts to the program and let you convert some not-persian letters with persian ones.
 *
 */
class PersianLetterService {
    /**
     * According to the options values, returns a RegExp object. The regex pattern of it contains regex of finding each of
     * elements those specified in the options object plus persian letters.
     * @private
     * @param {?} options
     * @return {?} a RegExp object that can use in searching a string for special characters (persian letters and others specified in the options)
     */
    static _stringValidationRegex(options) {
        /** @type {?} */
        let result = '';
        if (options.enDigits) {
            result += '0-9';
        }
        if (options.symbols) {
            result += PersianLetterService.SYMBOLS_PATTERN;
        }
        if (options.whitespaces) {
            result += PersianLetterService.WHITESPACES_PATTERN;
        }
        if (options.persianDigits) {
            result += PersianNumberService.persianNumberPattern;
        }
        // language=JSRegexp
        return new RegExp(`[${result + PersianLetterService.PERSIAN_LETTERS_PATTERN}]`, 'g');
    }
    /**
     * This method gets regex of persian letters and other chars specified in the options and then splits the input value by that regex.
     *
     * If match result is null - there is no match - returns 0. otherwise returns length of the match array that shows number of matched
     * occurred in the input value.
     * @private
     * @param {?} value
     * @param {?} options
     * @return {?} a number greater equal to 0 representing number of matches occurred in the input value.
     */
    static _getMatchedPatternLength(value, options) {
        /** @type {?} */
        const matchResult = value.match(PersianLetterService._stringValidationRegex(options));
        return matchResult ? matchResult.length : 0;
    }
    /**
     * If input value contains any persian letter or is an empty string, returns true. otherwise returns false.
     * @param {?} value
     * @return {?}
     */
    containsPersian(value) {
        if (value === undefined || value === null) {
            return false;
        }
        // language=JSRegexp
        /** @type {?} */
        const persianRegex = new RegExp(`[${PersianLetterService.PERSIAN_LETTERS_PATTERN}]`);
        return value.trim() ? persianRegex.test(value) : true;
    }
    /**
     * Checks if input value is a persian text or not. If input value contains any letter that is not persian, the output will be false.
     * Result of validation on existence  of other characters controls by options parameter.
     * @param {?} value
     * @param {?=} options controlling validation result on existence  of other characters controls by options parameter. Fields:
     *
     *        persianDigits: if sets to true, validation result will be true if input value contains persian digits plus persian letters.
     *
     *
     *        enDigits: if sets to true, validation result will be true if input value contains english digits plus persian letters
     *
     *
     *        symbols: if sets to true, validation result will be true if input value contains specific symbols plus persian letters.
     *                 symbols list: ?$-/:؟!~"'^_-[]{}()%&*><;
     *
     *
     *        whitespaces: if sets to true, validation result will be true if input value contains white spaces plus persian letters
     *
     *
     * You can combine any number of options field together.
     * @return {?}
     */
    isPersian(value, options = {
        persianDigits: false,
        enDigits: false,
        symbols: true,
        whitespaces: true
    }) {
        if (value === undefined || value === null) {
            return false;
        }
        return value.length === PersianLetterService._getMatchedPatternLength(value, options);
    }
    /**
     * Converts arabic letters: ي and ك to persian corresponding letters.
     * @param {?} value
     * @return {?}
     */
    toPersian(value) {
        return value.replace(/ي/g, 'ی').replace(/ك/g, 'ک');
    }
}
PersianLetterService.PERSIAN_LETTERS_PATTERN = '\u06A9\u06AF\u06C0\u06CC\u060C\u062A\u062B\u062C\u062D\u062E\u062F\u063A\u064A\u064B\u064C' +
    '\u064D\u064E\u064F\u067E\u0670\u0686\u0698\u200C\u0621-\u0629\u0630-\u0639\u0641-\u0654';
PersianLetterService.SYMBOLS_PATTERN = '؟$-/:-?،{-~!"^_`\\[\\]';
PersianLetterService.WHITESPACES_PATTERN = '\\s';
PersianLetterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ PersianLetterService.ngInjectableDef = ɵɵdefineInjectable({ factory: function PersianLetterService_Factory() { return new PersianLetterService(); }, token: PersianLetterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Reactive form validator that checks form control value contains only persian numbers.
 * @param {?=} persianNumberService
 * @return {?}
 */
function persianNumbersValidator(persianNumberService = new PersianNumberService()) {
    return (/**
     * @param {?} control
     * @return {?}
     */
    (control) => {
        return persianNumberService.isPersian(control.value) ? null : { 'persianNumberValidation': control.value };
    });
}
/**
 * Reactive form validator that checks form control value contains only persian letters and allowed characters in the options parameter.
 * @param {?=} options see documents of isPersian method of the PersianLetterService for more info about options.
 * @param {?=} persianLetterService
 * @return {?}
 */
function persianLettersValidator(options = {
    persianDigits: false,
    whitespaces: false,
    symbols: false,
    enDigits: false
}, persianLetterService = new PersianLetterService()) {
    return (/**
     * @param {?} control
     * @return {?}
     */
    (control) => {
        return persianLetterService.isPersian(control.value, options) ? null : { 'persianLetterValidation': control.value };
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * You can add PersianNumbersDirective property to your input tag for using persianNumbersValidator function on its value.
 *
 * [For more information also see persianNumbersValidator]{\@link persianNumbersValidator}
 */
class PersianNumbersDirective {
    /**
     * Only a wrapper for persianNumbersValidator validator function.
     * @param {?} control
     * @return {?} null for success or ValidationError for invalid inputs
     */
    validate(control) {
        return persianNumbersValidator()(control);
    }
}
PersianNumbersDirective.decorators = [
    { type: Directive, args: [{
                selector: 'PersianNumbersDirective',
                providers: [{ provide: NG_VALIDATORS, useExisting: PersianNumbersDirective }]
            },] }
];
/**
 * You can add PersianLetterDirective property to your input tag for using persianNumbersValidator function on its value
 * For setting options value, you can simply set PersianLetterDirective property equal to the PLOptions object.
 * [For more information also see persianLettersValidator]{\@link persianLettersValidator}
 */
class PersianLetterDirective {
    /**
     * Only a wrapper for persianLettersValidator validator function.
     * @param {?} control
     * @return {?} null for success or ValidationError for invalid inputs
     */
    validate(control) {
        return persianLettersValidator(this.options)(control);
    }
}
PersianLetterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'persianLettersValidator',
                providers: [{ provide: NG_VALIDATORS, useExisting: PersianLetterDirective }]
            },] }
];
PersianLetterDirective.propDecorators = {
    options: [{ type: Input, args: ['PersianLetterDirective',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Replaces all arabic and english numbers with persian numbers.
 * \@example {{englishTextDigit | faNum}}
 */
class FaNumPipe {
    /**
     * @param {?} persianNumberService
     */
    constructor(persianNumberService) {
        this.persianNumberService = persianNumberService;
    }
    /**
     *
     * @param {?} value a number or string (probably empty).
     * @return {?} a string that all english and arabic numbers in the input has been replaced with persian digits.
     */
    transform(value) {
        value = String(value);
        return this.persianNumberService.toPersian(value);
    }
}
FaNumPipe.decorators = [
    { type: Pipe, args: [{ name: 'faNum' },] }
];
/** @nocollapse */
FaNumPipe.ctorParameters = () => [
    { type: PersianNumberService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Replaces all persian numbers in the text to the english numbers.
 * \@example {{persianTextDigit | enNum}}
 */
class EnNumPipe {
    /**
     * @param {?} persianNumberService
     */
    constructor(persianNumberService) {
        this.persianNumberService = persianNumberService;
    }
    /**
     * @param {?} value a string containing one or more non-english digits. Could be an empty string.
     * @return {?} input value replaced all persian digits with english digits.
     */
    transform(value) {
        value = String(value);
        return this.persianNumberService.toEnglish(value);
    }
}
EnNumPipe.decorators = [
    { type: Pipe, args: [{ name: 'enNum' },] }
];
/** @nocollapse */
EnNumPipe.ctorParameters = () => [
    { type: PersianNumberService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const IRCurrencies = {
    rial: 'ریال',
    r: 'ریال',
    toman: 'تومان',
    t: 'تومان',
};
/**
 * Formats input as a currency value.
 * default type is rial. You can choose on of the following currency types:
 *
 *      r or rial for ریال
 *
 *      to or toman for تومان
 *
 *  This pipe extends DecimalPipe, so as second parameter, you can enter your desired formatting string. Default formatter is: 1.0-0
 */
class IRCurrencyPipe extends DecimalPipe {
    /**
     * \@example 1925100 -> 1,925,100 ریال
     * @param {?} value a number of a string only contains digits
     * @param {?=} type currency type
     * @param {?=} digitInfo decimal pipe formatter
     * @return {?}
     */
    transform(value, type = 'rial', digitInfo = '1.0-0') {
        value = Number(value);
        type = type.toLowerCase();
        if (isNaN(value)) {
            throw new Error(`${value} is not a acceptable number`);
        }
        return super.transform(value, digitInfo) + ' ' + IRCurrencies[type];
    }
}
IRCurrencyPipe.decorators = [
    { type: Pipe, args: [{ name: 'irc' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Formats a 10-digit number or string to national code format.
 */
class NationalCodePipe {
    /**
     * \@example 001-236547-5
     * @param {?} value a 10-digit number or a string only contains 10 digits.
     * @return {?} a formatted text from 10-digit input or an empty string if length of the input is not 10.
     */
    transform(value) {
        value = String(value);
        if (value.length !== 10) {
            return '';
        }
        return `${value.substring(0, 3)}-${value.substring(3, 9)}-${value[9]}`;
    }
}
NationalCodePipe.decorators = [
    { type: Pipe, args: [{ name: 'nationalCode' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This function removes fraction part of the number if exists. So, for example, it will turn -145,455 to -145 and
 * 145,455 to 145.
 * @param {?} x
 * @return {?}
 */
function round(x) {
    if (x < 0) {
        return Math.ceil(x);
    }
    else {
        return Math.floor(x);
    }
}
/**
 * This function returns integer part of division result of num1 and num2 numbers.
 *
 * For example: div (10, 3) is equal to 3.
 * @param {?} num1
 * @param {?} num2
 * @return {?}
 */
function div(num1, num2) {
    return round(num1 / num2);
}
/**
 * This function return arithmetic mod result of two inputs as a integer.
 * @param {?} num1
 * @param {?} num2
 * @return {?}
 */
function mod(num1, num2) {
    return num1 - div(num1, num2) * num2;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This Error will throw When inputted date is not a valid date according to the Jalali Calendar.
 */
class InvalidJalaliDateError extends Error {
    /**
     * @param {...?} params
     */
    constructor(...params) {
        super(...params);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        // @ts-ignore
        if (Error.captureStackTrace) {
            // @ts-ignore
            Error.captureStackTrace(this, InvalidJalaliDateError);
        }
        this.message = 'Invalid jalali date.';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Methods of this Service doing validation stuff on a Jalali date. You can use this Service using DI in all around of your app for
 * validating Jalali dates without needing to convert them to the Georgian Date.
 */
class JalaliDateValidatorService {
    constructor() { }
    /**
     * Returns number of days in a given month counting from 1.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth number of month from 0 for Farvardin to 11 for Esfand.
     * @return {?}
     */
    jMonthLength(jYear, jMonth) {
        if (jMonth < 6) {
            return 31;
        }
        if (jMonth < 11 || this.isJYearLeap(jYear)) {
            return 30;
        }
        return 29;
    }
    /**
     * Calculates the number of the leap years in jalali Calendar.
     * @param {?} targetJYear should be full year like: 1397 and should be between -61 to 3177.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L71}
     * @return {?}
     */
    numOfJLeapYears(targetJYear) {
        // Jalali years starting the 33-year rule.
        /** @type {?} */
        const breaks = [
            -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210,
            1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178,
        ];
        /** @type {?} */
        const breaksLength = breaks.length;
        /** @type {?} */
        let jp = breaks[0];
        /** @type {?} */
        let jump;
        /** @type {?} */
        let leapJ = -14;
        if (!this.isValidJYear(targetJYear)) {
            throw new InvalidJalaliDateError();
        }
        // Find the limiting years for the Jalali year jy.
        for (let i = 1; i < breaksLength; i += 1) {
            /** @type {?} */
            const jm = breaks[i];
            jump = jm - jp;
            if (targetJYear < jm) {
                break;
            }
            leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
            jp = jm;
        }
        /** @type {?} */
        const n = targetJYear - jp;
        // Find the number of leap years from AD 621 to the beginning
        // of the current Jalali year in the Persian Calendar.
        leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
        if (mod(jump, 33) === 4 && jump - n === 4) {
            leapJ += 1;
        }
        return leapJ;
    }
    /**
     * If JYear is a leap year in jalali Calendar, return true. We using the fact that if a year is leap, number of leap years until that year
     * and the year after it is not equal.
     * @param {?} jYear full jalali year like: 1397
     * @return {?}
     */
    isJYearLeap(jYear) {
        return this.numOfJLeapYears(jYear) !== this.numOfJLeapYears(jYear + 1);
    }
    /**
     * Checks if jalali year is in acceptable range or not.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L27}
     * @param {?} jYear full jalali year like 1397
     * @return {?}
     */
    isValidJYear(jYear) {
        return jYear >= JalaliDateValidatorService._minAcceptableYear && jYear <= JalaliDateValidatorService._maxAcceptableYear;
    }
    /**
     * Checks if jalali month is in valid range or not. In default, jMonth should start from zero.
     * If you want to start month number from one instead of zero, you should make startFromZero parameter to false.
     * @param {?} jMonth
     * @param {?=} startFromZero
     * @return {?}
     */
    isValidJMonth(jMonth, startFromZero = true) {
        /** @type {?} */
        let minMonthNumber = 0;
        /** @type {?} */
        let maxMonthNumber = 11;
        if (!startFromZero) {
            minMonthNumber++;
            maxMonthNumber++;
        }
        return jMonth >= minMonthNumber && jMonth <= maxMonthNumber;
    }
    /**
     * Checks if day number is in valid range according to the given year and month.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth month number starting from zero
     * @param {?} jDay day number starting from one
     * @return {?}
     */
    isValidJDay(jYear, jMonth, jDay) {
        return jDay <= this.jMonthLength(jYear, jMonth) && jDay > 0;
    }
    /**
     * If Jalali date is not a valid Jalali date, return false. otherwise returns true.
     * @param {?} jYear full year number like: 1397
     * @param {?} jMonth starts from zero
     * @param {?} jDay starts from one
     * @return {?}
     */
    isValidJDate(jYear, jMonth, jDay) {
        return this.isValidJYear(jYear) && this.isValidJMonth(jMonth) && this.isValidJDay(jYear, jMonth, jDay);
    }
}
JalaliDateValidatorService._minAcceptableYear = -61;
JalaliDateValidatorService._maxAcceptableYear = 3177;
JalaliDateValidatorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
JalaliDateValidatorService.ctorParameters = () => [];
/** @nocollapse */ JalaliDateValidatorService.ngInjectableDef = ɵɵdefineInjectable({ factory: function JalaliDateValidatorService_Factory() { return new JalaliDateValidatorService(); }, token: JalaliDateValidatorService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This class converts Jalali date to Georgian and vase versa. You can use all of the methods as static methods.
 *
 */
class JalaliDateCalculatorService {
    /**
     * @param {?} validator
     */
    constructor(validator) {
        this.validator = validator;
    }
    /**
     * Calculates the Julian Day number from Gregorian or Julian calendar dates.
     *
     * Only some code cleaning applied to the source code.
     *
     * The procedure was tested to be good since 1 March, -100100 (of both calendars) up to a few million years into the future.
     *
     * @param {?} gDate an instance of javascript date representing a Georgian date.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L195}
     * @return {?}
     */
    numberOfPassedGDays(gDate) {
        /** @type {?} */
        const gMonth = gDate.getMonth() - 7;
        /** @type {?} */
        const gYear = gDate.getFullYear() + 100100;
        /** @type {?} */
        const gMonthDiv = div(gMonth, 6);
        /** @type {?} */
        const result = div((gYear + gMonthDiv) * 1461, 4) + div(153 * mod(gMonth + 17, 12) + 2, 5) + gDate.getDate() - 34840408;
        return result - div(div(gYear + gMonthDiv, 100) * 3, 4) + 752;
    }
    /**
     * Returns number of passed days from source day in jalali calendar to the given jalali date.
     * @param {?} jYear full jalali year like 1397
     * @param {?} jMonth starts from zero
     * @param {?} jDay day number starts from one
     * @return {?}
     */
    numberOfPassedJDays(jYear, jMonth, jDay) {
        return this.numberOfPassedGDays(new Date(this.jalaliYearToGeorgianYear(jYear), 2, this.firstDayOfJYearInMarch(jYear))) +
            jMonth * 31 - div(jMonth + 1, 7) * (jMonth - 6) + jDay - 1;
    }
    /**
     * Creates a javascript Date object from number of passed days in Georgian calendar representing Georgian date.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L213}
     * @param {?} numOfDays
     * @return {?}
     */
    createGDateFromDays(numOfDays) {
        /** @type {?} */
        const j = (4 * numOfDays + 139361631) + div(div(4 * numOfDays + 183187720, 146097) * 3, 4) * 4 - 3908;
        /** @type {?} */
        const i = div(mod(j, 1461), 4) * 5 + 308;
        /** @type {?} */
        const gDay = div(mod(i, 153), 5) + 1;
        /** @type {?} */
        const gMonth = mod(div(i, 153), 12);
        /** @type {?} */
        const gYear = div(j, 1461) - 100100 + div(7 - gMonth, 6);
        return new Date(gYear, gMonth, gDay);
    }
    /**
     * This function returns number of passed leap years from AD 621 until targetGYear.
     * @param {?} targetGYear is full year number like 2018
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L110}
     * @return {?}
     */
    numOfGLeapYears(targetGYear) {
        return div(targetGYear, 4) - div((div(targetGYear, 100) + 1) * 3, 4) - 150;
    }
    /**
     * first day of the Farvardin month in Jalali calendar is in March month. This method returns the day number of new jalali year in March.
     * The day number starts from 1 not zero and is equal to the real numbers in the calendar.
     * @param {?} jYear full jalali year like 1397
     * @return {?}
     */
    firstDayOfJYearInMarch(jYear) {
        /** @type {?} */
        const gYear = jYear + 621;
        return this.validator.numOfJLeapYears(jYear) - this.numOfGLeapYears(gYear) + 20;
    }
    /**
     * Converts jalali year number to the georgian year. Output year is the georgian year that jalali year starts within it, not the year
     * that starts in the winter of jalali year.
     * @param {?} jYear full jalali year like 1397
     * @return {?}
     */
    jalaliYearToGeorgianYear(jYear) {
        return jYear + 621;
    }
    /**
     * Converts georgian year to the jalali year. Output year is the jalali year that start within the Georgian year.
     * @param {?} gYear full georgian year like 2018
     * @return {?}
     */
    georgianYearToJalaliYear(gYear) {
        return gYear - 621;
    }
    /**
     * this method converts Georgian date to the jalali date. Output is an object implementing SimpleDateInterface.
     *
     * ATTENTION: month number starts from 0, but day number starts from 1. Just like native javascript Date object.
     * @param {?} gDate Georgian date as a javascript Date object.
     *
     * [Implementation in source code]{\@link https://github.com/sijad/ts-jalaali/blob/296a7c2fa1816a5bbb0b11bbe3eb03ebc17059f6/src/jalaali.ts#L149}
     * @return {?}
     */
    convertToJalali(gDate) {
        /** @type {?} */
        const georgianYear = gDate.getFullYear();
        /** @type {?} */
        let jalaliYear = this.georgianYearToJalaliYear(georgianYear);
        /** @type {?} */
        const passedDays = this.numberOfPassedGDays(gDate);
        /** @type {?} */
        const numOfPassedDaysTo1Farvardin = this.numberOfPassedGDays(new Date(georgianYear, 2, this.firstDayOfJYearInMarch(jalaliYear)));
        /** @type {?} */
        let jalaliDay;
        /** @type {?} */
        let jalaliMonth;
        // Find number of days that passed since 1 Farvardin.
        /** @type {?} */
        let numOfDayInJYear = passedDays - numOfPassedDaysTo1Farvardin;
        if (numOfDayInJYear >= 0) {
            if (numOfDayInJYear <= 185) {
                // The first 6 months.
                jalaliMonth = div(numOfDayInJYear, 31);
                jalaliDay = mod(numOfDayInJYear, 31) + 1;
                return { year: jalaliYear, month: jalaliMonth, day: jalaliDay };
            }
            else {
                // The remaining months.
                numOfDayInJYear -= 186;
            }
        }
        else {
            // Previous Jalali year.
            jalaliYear -= 1;
            numOfDayInJYear += 179;
            if (this.validator.isJYearLeap(jalaliYear)) {
                numOfDayInJYear += 1;
            }
        }
        jalaliMonth = 6 + div(numOfDayInJYear, 30);
        jalaliDay = mod(numOfDayInJYear, 30) + 1;
        return { year: jalaliYear, month: jalaliMonth, day: jalaliDay };
    }
    /**
     * Converts a valid jalali date to a javascript Date object representing a equivalent Georgian date.
     * @throws InvalidJalaliDateError when inputted date is not a valid Jalali date.
     * @param {?} jYear a full Jalali year like 1397
     * @param {?} jMonth starts from zero
     * @param {?} jDay starts from 1
     * @return {?}
     */
    convertToGeorgian(jYear, jMonth, jDay) {
        if (!this.validator.isValidJDate(jYear, jMonth, jDay)) {
            throw new InvalidJalaliDateError();
        }
        return this.createGDateFromDays(this.numberOfPassedJDays(jYear, jMonth, jDay));
    }
}
JalaliDateCalculatorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
JalaliDateCalculatorService.ctorParameters = () => [
    { type: JalaliDateValidatorService }
];
/** @nocollapse */ JalaliDateCalculatorService.ngInjectableDef = ɵɵdefineInjectable({ factory: function JalaliDateCalculatorService_Factory() { return new JalaliDateCalculatorService(ɵɵinject(JalaliDateValidatorService)); }, token: JalaliDateCalculatorService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This class represents a complete Date object for Jalali dates. It accepts jalali Dates, converts Georgian dates to jalali and implements
 * all the behaviours of default Date object of JavaScript for Jalali Date, plus some additional methods for developers convenience.
 *
 * ATTENTION:
 *
 * UTC methods are not implemented for Jalali date. They working directly on gDate object (Corresponding date in Georgian) and changing
 * properties of this. Then new JDate object will create from the modified Georgian Date. So they may Cause unpredictable behaviour.
 * Please don't use UTC methods with "todo" tag on them unless you are sure about the behaviour.
 * Recreating objects are safer than working with UTC methods.
 */
class JDate {
    /**
     * For creating a JDate object, you have 5 different options.
     *
     * 1- If you want to have current date and time, you can simply call new JDate() without any parameter.
     *
     * 2- If you want to create JDate object from a jalali date string as described in the `pars` method document, you can pass that string as
     *    first parameter and leave others empty.
     *
     * 3 - If you want to create JDate object from number of passed milliseconds from UNIX epoch (for example creating a Jalali date object
     *     from result of getTime method of another Date object), you can pass the number as first parameter and leave others alone.
     *
     * 4 - If you want to create JDate object from a Georgian Date object, you can simply pass that Date object as first parameter and leave
     *     others empty.
     *
     * 5- If you want to create JDate object from date and time values, you can simply fill corresponding parameters of each date and time
     * value to the constructor. You don't have to fill all of the parameters. only those you need. other parameters will fill with zero.
     * Examples of all of those scenarios:
     *
     * \@example new JDate() / new JDate('11 دی 1348 00:00:00') / new JDate(-12600000) / new JDate(new Date(2018, 0, 1)) / new JDate(1397, 0, 25) / new JDate(1397, 11, 25, 12, 32, 45, 123)
     * @throws InvalidJalaliDateError
     * @param {?=} jYear
     * @param {?=} jMonth Month number starting from 0 and should be LESSER than 12.
     * @param {?=} jDay
     * @param {?=} hours
     * @param {?=} minutes
     * @param {?=} seconds
     * @param {?=} milliseconds
     */
    constructor(jYear, jMonth, jDay, hours = 0, minutes = 0, seconds = 0, milliseconds = 0) {
        this._calculator = new JalaliDateCalculatorService(new JalaliDateValidatorService());
        if (!jYear) {
            this._createFromDate(new Date());
        }
        else if (typeof jYear === 'string' && jMonth === undefined) {
            this._createFromDate(new Date(JDate.parse(jYear)));
        }
        else if (typeof jYear === 'number' && jMonth === undefined) {
            this._createFromDate(new Date(jYear));
        }
        else if (jYear instanceof Date && jMonth === undefined) {
            this._createFromDate(jYear);
        }
        else {
            // @ts-ignore
            this._gDate = this._calculator.convertToGeorgian(jYear, jMonth, jDay);
            // @ts-ignore
            this._jYear = jYear;
            this._jMonth = jMonth;
            this._jDay = jDay;
            this._gDate.setHours(hours, minutes, seconds, milliseconds);
        }
        this._check_date_validity();
    }
    /**
     * If input value length is shorter than desiredLength, adds zeros at the beginning of it until meets desired length.
     * @param {?} value a number or string that we want have a specific length
     * @param {?} desiredLength length of output string. If be shorter than input length, input will return.
     * @return {?}
     */
    static zeroPadding(value, desiredLength) {
        value = value.toString();
        while (value.length < desiredLength) {
            value = '0' + value;
        }
        return value;
    }
    /**
     * Extracts Georgian Date object from a Jalali date string.
     * \@example 11 دی 1348 00:00:00 / 11 Dey 1348 00:00:00
     * @param {?} dateString a Jalali date string following this pattern:
     *
     *        "yyyy mmm dd HH:MM:SS"
     *        or this pattern:
     *
     *        "yyyy mmmm dd HH:MM:SS".
     * @return {?} a Georgian Date object.
     */
    static parse(dateString) {
        /** @type {?} */
        const calculator = new JalaliDateCalculatorService(new JalaliDateValidatorService());
        /** @type {?} */
        const dateArray = dateString.split(' ');
        if (dateArray.length < 3) {
            throw new InvalidJalaliDateError();
        }
        /** @type {?} */
        const day = parseInt(dateArray[0]);
        /** @type {?} */
        let month = JDate.FA_MONTHS.indexOf(dateArray[1]);
        if (month === -1) {
            month = JDate.EN_MONTHS.indexOf(dateArray[1]);
        }
        if (month === -1) {
            throw new InvalidJalaliDateError();
        }
        /** @type {?} */
        const year = parseInt(dateArray[2]);
        /** @type {?} */
        const timeArray = dateArray.length > 3 ? dateArray[3].split(':') : ['0', '0', '0'];
        /** @type {?} */
        const hour = parseInt(timeArray[0]);
        /** @type {?} */
        const min = parseInt(timeArray[1]);
        /** @type {?} */
        const sec = parseInt(timeArray[2]);
        /** @type {?} */
        const gDate = calculator.convertToGeorgian(year, month, day);
        gDate.setHours(hour, min, sec);
        return gDate.getTime();
    }
    /**
     * This method recalculates the gDate value with private attributes those storing Jalali date parts.
     * @private
     * @return {?}
     */
    _renewGDate() {
        this._gDate = this._calculator.convertToGeorgian(this._jYear, this._jMonth, this._jDay);
    }
    /**
     * Sets Jalali year value to the input parameter and recalculates gDate attribute.
     * @private
     * @param {?} value full Jalali year like 1397
     * @return {?}
     */
    set jYear(value) {
        this._jYear = value;
        this._check_date_validity();
        this._renewGDate();
    }
    /**
     * Sets Jalali month value to the input parameter and recalculates gDate attribute.
     * @private
     * @param {?} value month number starting from zero
     * @return {?}
     */
    set jMonth(value) {
        this._jMonth = value;
        this._check_date_validity();
        this._renewGDate();
    }
    /**
     * Sets Jalali day value to the input parameter and recalculates gDate attribute.
     * @private
     * @param {?} value day number starting from 1.
     * @return {?}
     */
    set jDay(value) {
        this._jDay = value;
        this._check_date_validity();
        this._renewGDate();
    }
    /**
     * throws InvalidJalaliDateError when date values of this object won't represent a valid Jalali date.
     * Otherwise nothing happens.
     * @throws InvalidJalaliDateError
     * @private
     * @return {?}
     */
    _check_date_validity() {
        if (!this._calculator.validator.isValidJDate(this._jYear, this._jMonth, this._jDay)) {
            throw new InvalidJalaliDateError();
        }
    }
    /**
     * Calculates Jalali year from Georgian Date object and sets the attributes of the object to proper values.
     * @private
     * @param {?} gDate
     * @return {?}
     */
    _createFromDate(gDate) {
        /** @type {?} */
        const conversionResult = this._calculator.convertToJalali(gDate);
        this._jYear = conversionResult.year;
        this._jMonth = conversionResult.month;
        this._jDay = conversionResult.day;
        this._gDate = gDate;
    }
    /**
     * @param {?} hint
     * @return {?}
     */
    [Symbol.toPrimitive](hint) {
        return undefined;
    }
    /**
     * @return {?} a regular javascript Date object representing Georgian date corresponding to the Jalili date of the JDate object.
     */
    getGeorgianDate() {
        return this._gDate;
    }
    /**
     * @return {?} the day of the month for the specified date according to local time.
     */
    getDate() {
        return this._jDay;
    }
    /**
     * @return {?} the day of the week for the specified date according to local time, where 0 represents Friday and 6 is Thursday.
     */
    getDay() {
        return (this._gDate.getDay() + 2) % 7;
    }
    /**
     * \@example 1397 / 100
     *
     * @return {?} the year (4 digits for years greater than 999) of the specified date according to local time
     */
    getFullYear() {
        return this._jYear;
    }
    /**
     * \@example 10
     * @return {?} the hour for the specified date, according to local time.
     */
    getHours() {
        return this._gDate.getHours();
    }
    /**
     * Converts default 24-hour clock hour value to the 12-hour clock version.
     * @return {?} a number between 1 to 12
     */
    getHours12hourClock() {
        /** @type {?} */
        const result = this.getHours() % 12;
        return result ? result : 12;
    }
    /**
     * @return {?} the milliseconds in the specified date according to local time.
     */
    getMilliseconds() {
        return this._gDate.getMilliseconds();
    }
    /**
     * \@Return the minutes in the specified date according to local time.
     * @return {?}
     */
    getMinutes() {
        return this._gDate.getMinutes();
    }
    /**
     * @return {?} the month in the specified date according to local time, as a zero-based value
     * where zero indicates the first month of the year.
     */
    getMonth() {
        return this._jMonth;
    }
    /**
     * @return {?} the seconds in the specified date according to local time.
     */
    getSeconds() {
        return this._gDate.getSeconds();
    }
    /**
     * JavaScript uses milliseconds as the unit of measurement, whereas Unix Time is in seconds.
     *
     * getTime() always uses UTC for time representation. For example, a client browser in one timezone, getTime() will be the same as a
     * client browser in any other timezone.
     *
     * You can use this method to help assign a date and time to another Date object. This method is functionally equivalent to the valueOf() method.
     * @return {?} the number of milliseconds since the Unix Epoch.
     */
    getTime() {
        return this._gDate.getTime();
    }
    /**
     * Attention: Not implemented
     * \@todo add implementation
     * @return {?} the time zone difference, in minutes, from current locale (host system settings) to UTC
     */
    getTimezoneOffset() {
        return this._gDate.getTimezoneOffset();
    }
    /**
     * Output is not jalali day.
     * \@todo add implementation
     * @return {?} getUTCDate of the corresponding Georgian date.
     */
    getUTCDate() {
        return this._gDate.getUTCDate();
    }
    /**
     * Output is not jalali day.
     * \@todo add implementation
     * @return {?} getUTCDay of the corresponding Georgian date.
     */
    getUTCDay() {
        return this._gDate.getUTCDay();
    }
    /**
     * Output is not a Jalali Year.
     * \@todo add implementation
     * @return {?} getUTCFullYear of the corresponding Georgian date.
     */
    getUTCFullYear() {
        return this._gDate.getUTCFullYear();
    }
    /**
     * \@todo add implementation
     * @return {?} getUTCHours of the corresponding Georgian date.
     */
    getUTCHours() {
        return this._gDate.getUTCHours();
    }
    /**
     * \@todo add implementation
     * @return {?} getUTCMilliseconds of the corresponding Georgian date.
     */
    getUTCMilliseconds() {
        return this._gDate.getUTCMilliseconds();
    }
    /**
     * \@todo add implementation
     * @return {?} getUTCMinutes of the corresponding Georgian date.
     */
    getUTCMinutes() {
        return this._gDate.getUTCMinutes();
    }
    /**
     * Output is not a Jalali Year.
     * \@todo add implementation
     * @return {?} getUTCMonth of the corresponding Georgian date.
     */
    getUTCMonth() {
        return this._gDate.getUTCMonth();
    }
    /**
     * \@todo add implementation
     * @return {?} getUTCSeconds of the corresponding Georgian date.
     */
    getUTCSeconds() {
        return this._gDate.getUTCSeconds();
    }
    /**
     * sets the day of the JDate object relative to the beginning of the currently set month.
     * @param {?} date day number starts from 1.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the given date (the Date object is also changed in place).
     */
    setDate(date) {
        this.jDay = date;
        return this.getTime();
    }
    /**
     * sets the full year for a specified date according to local time. Returns new timestamp.
     * @param {?} year full Jalali year like 1397
     * @param {?=} month number of month starting from 0
     * @param {?=} date number of day starting from 1
     * @return {?}
     */
    setFullYear(year, month, date) {
        this.jYear = year;
        if (month) {
            this.jMonth = month;
        }
        if (date) {
            this.jDay = date;
        }
        return this.getTime();
    }
    /**
     * Sets the hours for a specified date according to local time, and returns the number of milliseconds since
     * January 1, 1970 00:00:00 UTC until the time represented by the updated JDate instance.
     * @param {?} hours An integer between 0 and 23, representing the hour
     * @param {?=} min An integer between 0 and 59, representing the minutes.
     * @param {?=} sec An integer between 0 and 59, representing the seconds.
     * @param {?=} ms A number between 0 and 999, representing the milliseconds.
     * @return {?} The number of milliseconds between January 1, 1970 00:00:00 UTC and the updated date.
     */
    setHours(hours, min, sec, ms) {
        this._gDate.setHours(hours);
        if (min !== undefined) {
            this.setMinutes(min);
        }
        if (sec !== undefined) {
            this.setSeconds(sec);
        }
        if (ms !== undefined) {
            this.setMilliseconds(ms);
        }
        return this.getTime();
    }
    /**
     * Sets the milliseconds for a specified date according to local time.
     * @param {?} ms A number between 0 and 999, representing the milliseconds.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setMilliseconds(ms) {
        this._gDate.setMilliseconds(ms);
        return this.getTime();
    }
    /**
     * Sets the minutes for a specified date according to local time.
     * @param {?} min An integer between 0 and 59, representing the minutes.
     * @param {?=} sec An integer between 0 and 59, representing the seconds.
     * @param {?=} ms A number between 0 and 999, representing the milliseconds.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setMinutes(min, sec, ms) {
        this._gDate.setMinutes(min);
        if (sec !== undefined) {
            this.setSeconds(sec);
        }
        if (ms !== undefined) {
            this.setMilliseconds(ms);
        }
        return this.getTime();
    }
    /**
     * Sets the month for a specified date according to the currently set year.
     * @param {?} month An integer between 0 and 11, representing the months Farvardin through Esfand.
     * @param {?=} date An integer from 1 to 31, representing the day of the month.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setMonth(month, date) {
        this.jMonth = month;
        if (date !== undefined) {
            this.jDay = date;
        }
        return this.getTime();
    }
    /**
     * Sets the seconds for a specified date according to local time.
     * @param {?} sec An integer between 0 and 59, representing the seconds.
     * @param {?=} ms A number between 0 and 999, representing the milliseconds.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setSeconds(sec, ms) {
        this._gDate.setSeconds(sec);
        if (ms !== undefined) {
            this.setMilliseconds(ms);
        }
        return this.getTime();
    }
    /**
     * Sets the JDate object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC.
     * @param {?} time sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setTime(time) {
        this._createFromDate(new Date(time));
        return time;
    }
    /**
     * sets the day of the month for a specified date according to universal time.
     * Then recreate the JDate object from new Georgian object.
     * \@todo add implementation
     * @param {?} date An integer from 1 to 31, representing the day of the month.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setUTCDate(date) {
        this._gDate.setUTCDate(date);
        this._createFromDate(this._gDate);
        return this.getTime();
    }
    /**
     * Sets the full year for a specified date according to universal time.
     * Then recreate the JDate object from new Georgian object.
     * \@todo add implementation
     * @param {?} year  An integer specifying the numeric value of the year, for example, 1995.
     * @param {?=} month  Optional. An integer between 0 and 11 representing the months January through December.
     * @param {?=} date An integer between 1 and 31 representing the day of the month. If you specify the dayValue parameter, you must also
     * specify the monthValue.
     * @return {?}
     */
    setUTCFullYear(year, month, date) {
        this._gDate.setUTCFullYear(year, month, date);
        this._createFromDate(this._gDate);
        return this.getTime();
    }
    /**
     * Sets the hour for a specified date according to universal time, and returns the number of milliseconds since
     * January 1, 1970 00:00:00 UTC until the time represented by the updated Date instance.
     * Then recreate the JDate object from new Georgian object.
     * \@todo add implementation
     * @param {?} hours  An integer between 0 and 23, representing the hour.
     * @param {?=} min Optional. An integer between 0 and 59, representing the minutes.
     * @param {?=} sec Optional. An integer between 0 and 59, representing the seconds. If you specify the secondsValue parameter,
     *        you must also specify the minutesValue.
     * @param {?=} ms Optional. A number between 0 and 999, representing the milliseconds. If you specify the msValue parameter,
     *        you must also specify the minutesValue and secondsValue.
     * @return {?} The number of milliseconds between January 1, 1970 00:00:00 UTC and the updated date.
     */
    setUTCHours(hours, min, sec, ms) {
        this._gDate.setUTCHours(hours, min, sec, ms);
        this._createFromDate(this._gDate);
        return this.getTime();
    }
    /**
     * Sets the milliseconds for a specified date according to universal time.
     *
     * Then recreate the JDate object from new Georgian object.
     * \@todo add implementation
     * @param {?} ms A number between 0 and 999, representing the milliseconds.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setUTCMilliseconds(ms) {
        this._gDate.setUTCMilliseconds(ms);
        this._createFromDate(this._gDate);
        return this.getTime();
    }
    /**
     * Sets the minutes for a specified date according to universal time.
     *
     * Then recreate the JDate object from new Georgian object.
     * \@todo add implementation
     * @param {?} min An integer between 0 and 59, representing the minutes.
     * @param {?=} sec Optional. An integer between 0 and 59, representing the seconds. If you specify the secondsValue parameter,
     *        you must also specify the minutesValue.
     * @param {?=} ms Optional. A number between 0 and 999, representing the milliseconds. If you specify the msValue parameter,
     *        you must also specify the minutesValue and secondsValue.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setUTCMinutes(min, sec, ms) {
        this._gDate.setUTCMinutes(min, sec, ms);
        this._createFromDate(this._gDate);
        return this.getTime();
    }
    /**
     * Sets the month for a specified date according to universal time.
     *
     * Then recreate the JDate object from new Georgian object.
     * \@todo add implementation
     * @param {?} month An integer between 0 and 11, representing the months January through December.
     * @param {?=} date Optional. An integer from 1 to 31, representing the day of the month.
     * @return {?} The number of milliseconds between 1 January 1970 00:00:00 UTC and the updated date.
     */
    setUTCMonth(month, date) {
        this._gDate.setUTCMonth(month, date);
        this._createFromDate(this._gDate);
        return this.getTime();
    }
    /**
     * Sets the seconds for a specified date according to universal time.
     *
     * Then recreate the JDate object from new Georgian object.
     * \@todo add implementation
     * @param {?} sec An integer between 0 and 59, representing the seconds.
     * @param {?=} ms Optional. A number between 0 and 999, representing the milliseconds.
     * @return {?}
     */
    setUTCSeconds(sec, ms) {
        this._gDate.setUTCSeconds(sec, ms);
        this._createFromDate(this._gDate);
        return this.getTime();
    }
    /**
     * \@example دوشنبه
     * @return {?} name of the day of the week in persian.
     */
    getNameOfTheDay() {
        return JDate.DAYS_OF_WEEK[this.getDay()];
    }
    /**
     * \@example مهر
     * @return {?} name of the month in persian.
     */
    getNameOfTheMonth() {
        return JDate.FA_MONTHS[this.getMonth()];
    }
    /**
     * returns the date portion of a Date object in human readable form in Persian.
     * \@example پنج‌شنبه اسفند 30 1375
     * @return {?} a string following this pattern: "nameOfTheDay nameOfTheMonth dayNumber fullYear".
     */
    toDateString() {
        return `${this.getNameOfTheDay()} ${this.getNameOfTheMonth()} ${this.getDate()} ${this.getFullYear()}`;
    }
    /**
     * Returns time marker of object time. all hour numbers lesser than 12 are before noon and all greater than 12 are after noon.
     * @param {?=} shortVersion controls output. if be true, output will be in short format like: ب.ظ if be false, output will be in complete format like: بعد از ظهر
     * @return {?} time marker for showing if time is before noon or after it
     */
    getTimeMarker(shortVersion = false) {
        if (this.getHours() < 12) {
            return shortVersion ? JDate.SHORT_BEFORE_NOON : JDate.COMPLETE_BEFORE_NOON;
        }
        return shortVersion ? JDate.SHORT_AFTER_NOON : JDate.COMPLETE_AFTER_NOON;
    }
    /**
     * Replace patterns of date formatting with corresponding strings from JDate object values.
     * In bi-character pattern parts, missed digits will fill with zero.
     * @private
     * @param {?} pattern a pattern string with replaceable parts:
     *
     *        yyyy -> Year number in 4-digit representation. ex: 1397
     *
     *        yy -> Year number in 2-digit representation. ex: 97
     *
     *        mmmm -> Name of the month in English representation. ex: Esfand
     *
     *        mmm -> Name of the month in Persian representation. ex: اسفند
     *
     *        mm -> 2-digit number of the month starting from 1
     *
     *        m -> non zero-padding number of the month starting from 1
     *
     *        dddd -> Name of the day in the week in English representation. ex: Shanbe
     *
     *        ddd -> Name of the day in the week id Persian representation. ex: شنبه
     *
     *        dd -> 2-digit number of the day in the month starting from 1
     *
     *        d -> non zero-padding number of the day in the month starting from 1
     *
     * @return {?} A formatted string that all Date pattern parts has been replaced. Other characters of the pattern will left unchanged.
     */
    _format_date(pattern) {
        return pattern.replace(/yyyy/g, JDate.zeroPadding(this.getFullYear(), 4))
            .replace(/\byy\b/g, (this.getFullYear() % 100).toString())
            .replace(/\bmmmm\b/g, JDate.EN_MONTHS[this.getMonth()])
            .replace(/\bmmm\b/g, JDate.FA_MONTHS[this.getMonth()])
            .replace(/\bmm\b/g, JDate.zeroPadding(this.getMonth() + 1, 2))
            .replace(/\bm\b/g, (this.getMonth() + 1).toString())
            .replace(/\bdddd\b/g, JDate.EN_DAYS_OF_WEEK[this.getDay()])
            .replace(/\bddd\b/g, JDate.DAYS_OF_WEEK[this.getDay()])
            .replace(/\bdd\b/g, JDate.zeroPadding(this.getDate(), 2))
            .replace(/\bd\b/g, this.getDate().toString());
    }
    /**
     * Replace patterns of time formatting with corresponding strings from JDate object values.
     *
     * In bi-character pattern parts, missed digits will fill with zero.
     * @private
     * @param {?} pattern a pattern string with replaceable parts:
     *
     *        HH -> 2-digit form of hour number in 24-hour clock format.
     *
     *        H -> non zero-padding form of hour number in 24-hour clock format.
     *
     *        hh -> 2-digit form of hour number in 12-hour clock format.
     *
     *        h -> non zero-padding form of hour number in 12-hour clock format.
     *
     *        H -> non zero-padding form of hour number in 12-hour clock format.
     *
     *        MM -> 2-digit form of minutes number.
     *
     *        M -> non zero-padding form of minutes number
     *
     *        SS -> 2-digit form of seconds number.
     *
     *        S -> non zero-padding form of seconds number.
     *
     *        l -> number of milliseconds
     *
     *        T -> Time marker in full format like: قبل از ظهر
     *
     *        t -> Time marker in short format like: ق.ظ
     * @return {?}
     */
    _format_time(pattern) {
        return pattern.replace(/\bHH\b/g, JDate.zeroPadding(this.getHours(), 2))
            .replace(/\bH\b/g, this.getHours().toString())
            .replace(/\bhh\b/g, JDate.zeroPadding(this.getHours12hourClock(), 2))
            .replace(/\bh\b/g, this.getHours12hourClock().toString())
            .replace(/\bMM\b/g, JDate.zeroPadding(this.getMinutes(), 2))
            .replace(/\bM\b/g, this.getMinutes().toString())
            .replace(/\bSS\b/g, JDate.zeroPadding(this.getSeconds(), 2))
            .replace(/\bS\b/g, this.getSeconds().toString())
            .replace(/\bl\b/g, this.getMilliseconds().toString())
            .replace(/\bT\b/g, this.getTimeMarker(false))
            .replace(/\bt\b/g, this.getTimeMarker(true));
    }
    /**
     * This method format date and time stored in the JDate object according to the entered pattern.
     *
     * Only masks will replace and all other characters will be unchanged after formatting.
     *
     * You can use masks several times in a pattern but be careful because if some of masks written immediately, they create new masks with
     * different meaning. It's better to always have some splitter characters between different masks.
     * @param {?} pattern a string containing zero or more formatting mask.
     *
     * Masks:
     *
     *        yyyy -> Year number in 4-digit representation. Leading zero for years lesser than 1000 ex: 1397
     *
     *        yy -> Year number in 2-digit representation without Leading zeros. ex: 97
     *
     *        mmmm -> Name of the month in English representation. ex: Esfand
     *
     *        mmm -> Name of the month in Persian representation. ex: اسفند
     *
     *        mm -> 2-digit number of the month starting from 1. Leading zero for single-digit months.
     *
     *        m -> number of the month starting from 1 without Leading zeros.
     *
     *        dddd -> Name of the day in the week in English representation. ex: Shanbe
     *
     *        ddd -> Name of the day in the week id Persian representation. ex: شنبه
     *
     *        dd -> 2-digit number of the day in the month starting from 1. Leading zero for single-digit days.
     *
     *        d -> number of the day in the month starting from 1 without Leading zeros.
     *
     *        HH -> 2-digit form of hour number in 24-hour clock format. Leading zero for single-digit hours.
     *
     *        H -> non zero-padding form of hour number in 24-hour clock format without Leading zeros.
     *
     *        hh -> 2-digit form of hour number in 12-hour clock format. Leading zero for single-digit hours.
     *
     *        H -> non zero-padding form of hour number in 12-hour clock format without Leading zeros.
     *
     *        MM -> 2-digit form of minutes number. Leading zero for single-digit minutes.
     *
     *        M -> non zero-padding form of minutes number without Leading zeros.
     *
     *        SS -> 2-digit form of seconds number. Leading zero for single-digit seconds.
     *
     *        S -> non zero-padding form of seconds number without Leading zeros.
     *
     *        l -> number of milliseconds without Leading zeros.
     *
     *        T -> Time marker in full format like: قبل از ظهر
     *
     *        t -> Time marker in short format like: ق.ظ
     * @return {?} formatted dateTime string.
     */
    format(pattern) {
        return this._format_time(this._format_date(pattern));
    }
    /**
     * @return {?} a string in simplified extended ISO format (ISO 8601), which is always 24 or 27 characters long (yyyy-mm-ddTHH:MM:SS.lZ).
     *        Be careful because that T in the middle of the pattern is not a format Mask and is a simple character.
     */
    toISOString() {
        return this.format('yyyy-mm-dd') + 'T' + this.format('HH:MM:SS.l') + 'Z';
    }
    /**
     * @param {?=} key
     * @return {?} a string representation of the Date object.
     * [see toString method]{\@link toString}
     */
    toJSON(key) {
        return this.toString();
    }
    /**
     * returns formatted date with following pattern: 'ddd mmm d yyyy HH:MM:SS'
     * @return {?}
     */
    toString() {
        return this.format('ddd mmm d yyyy HH:MM:SS');
    }
    /**
     * @param {?=} locales
     * @param {?=} options
     * @return {?}
     */
    toLocaleDateString(locales, options) {
        return this._gDate.toLocaleDateString(locales, options);
    }
    /**
     * @param {?=} locales
     * @param {?=} options
     * @return {?}
     */
    toLocaleTimeString(locales, options) {
        return this._gDate.toLocaleTimeString(locales, options);
    }
    /**
     * @return {?} toTimeString of Georgian date
     *
     * [For more information see javascript Date object documentation about this method]{\@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toTimeString}
     */
    toTimeString() {
        return this._gDate.toTimeString();
    }
    /**
     * \@todo add implementation
     * @return {?} toUTCString of Georgian date.
     *
     * [For more information see javascript Date object documentation about this method]{\@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString}
     */
    toUTCString() {
        return this._gDate.toUTCString();
    }
    /**
     * Similar to the getTime method.
     *
     * [For more information also see getTime method]{\@link getTime}
     * @return {?}
     */
    valueOf() {
        return this.getTime();
    }
    /**
     * @param {?} incValue
     * @return {?}
     */
    addMonth(incValue) {
        // let newMonth: number = (this.getMonth() + incValue) % 11;
        // let passedYears: number = this.getFullYear() + newMonth / 11;
        // let newYear: number = newMonth === 0 ? ;
        // this.setFullYear(newYear);
        // this.setMonth(newMonth % 11);
    }
}
JDate.EN_MONTHS = ['Farvardin', 'Ordibehesht', 'Khordad', 'Tir', 'Mordad', 'Shahrivar', 'Mehr', 'Aban', 'Azar', 'Dey', 'Behman', 'Esfand'];
JDate.FA_MONTHS = ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'];
JDate.DAYS_OF_WEEK = ['جمعه', 'شنبه', 'یکشنبه', 'دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنج‌شنبه'];
JDate.EN_DAYS_OF_WEEK = ['Jom\'e', 'Shanbe', 'Yekshanbe', 'Doshanbe', 'Seshanbe', 'Cheharshanbe', 'Panjshanbe'];
JDate.COMPLETE_BEFORE_NOON = 'قبل از ظهر';
JDate.COMPLETE_AFTER_NOON = 'بعد از ظهر';
JDate.SHORT_BEFORE_NOON = 'ق.ظ';
JDate.SHORT_AFTER_NOON = 'ب.ظ';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const FromatNames = {
    'short': 'yy/m/d h:M t',
    'shortDate': 'yy/m/d h:M t',
    'medium': 'd mmm yyyy، h:M t',
    'mediumDate': 'd mmm yyyy، h:M t',
    'long': 'd mmm yyyy، h:M:S T',
    'longDate': 'd mmm yyyy، h:M:S T',
    'shortTime': 'h:M t',
    'mediumTime': 'h:M:S t',
    'longTime': 'h:M:S.l T',
};
/**
 * Formats JDate objects or convert Date objects (or any instance of classes those implement that interface) to a `JDate` object and format
 * that according to the given format.
 *
 * The result of this pipe is not reevaluated when the input is mutated. To avoid the need to reformat the date on every change-detection
 * cycle, treat the date as an immutable object and change the reference when the pipe needs to run again.
 *
 * You can pass a format pattern string like [JDate format method]{\@link https://alihoseiny.github.io/ngx-persian/classes/JDate.html#format}
 *
 * Also you can use pre-defined format names described below:
 *
 *        'short': equivalent to yy/m/d h:M t {\@example '97/2/23 12:12 ب.ظ'}
 *
 *        'shortDate': same as short
 *
 *        'medium': equivalent to 'd mmm yyyy، h:M t' {\@example '23 اردیبهشت 1397، 12:12 ب.ظ'}
 *
 *        'mediumDate': same as medium
 *
 *        'long': equivalent to 'd mmm yyyy، h:M:S T' {\@example '23 اردیبهشت 1397، 12:12:30 بعد از ظهر'}
 *
 *        'longDate': same as long
 *
 *        'shortTime': equivalent to 'h:M t' {\@example '12:12 ب.ظ'}
 *
 *        'mediumTime': equivalent to 'h:M:S t' {\@example '12:12:30 ب.ظ'}
 *
 *        'longTime': equivalent to 'h:M:S.l T' {\@example '12:12:30.300 بعد از ظهر'}
 *
 *  Default format is `medium`.
 */
class JdatePipe {
    /**
     * Checks if `formatName` is in the `FromatNames` enum. If it is, returns related format string. Else returns `formatName` string
     * without any change.
     * @private
     * @param {?} formatName format name or format pattern string
     * @return {?} formatting pattern string
     */
    static convertNameToFormat(formatName) {
        if (!FromatNames[formatName]) {
            return formatName;
        }
        return FromatNames[formatName];
    }
    /**
     * Formatting the date using `format` method of it with proper formatting pattern created from `format`
     * @param {?} value a Jalali Date object or an instance of `Date` object or any class implementing that interface
     * @param {?=} format format name or format pattern string
     * @return {?}
     */
    transform(value, format = 'mediumDate') {
        if (!(value instanceof JDate)) {
            value = new JDate(value);
        }
        // @ts-ignore
        return value.format(JdatePipe.convertNameToFormat(format));
    }
}
JdatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'jdate'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPersianModule {
}
NgxPersianModule.decorators = [
    { type: NgModule, args: [{
                declarations: [PersianLetterDirective, PersianNumbersDirective, FaNumPipe, EnNumPipe, IRCurrencyPipe, NationalCodePipe, JdatePipe],
                imports: [],
                exports: [PersianLetterDirective, PersianNumbersDirective, FaNumPipe, EnNumPipe, IRCurrencyPipe, NationalCodePipe, JdatePipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * When mobile phone number is not valid this error will throw.
 */
class InvalidMobilePhoneNumberError extends Error {
    /**
     * @param {...?} params
     */
    constructor(...params) {
        super(...params);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        // @ts-ignore
        if (Error.captureStackTrace) {
            // @ts-ignore
            Error.captureStackTrace(this, InvalidMobilePhoneNumberError);
        }
        this.message = 'This phone number is not valid.';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This error will throw when there is no valid mobile operator for inputted mobile phone number.
 */
class InvalidMobileOperatorError extends Error {
    /**
     * @param {...?} params
     */
    constructor(...params) {
        super(...params);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        // @ts-ignore
        if (Error.captureStackTrace) {
            // @ts-ignore
            Error.captureStackTrace(this, InvalidMobileOperatorError);
        }
        this.message = 'Operator of this number is not recognizable.';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const operatorsNames = {
    irancell: 'ایرانسل',
    mci: 'همراه اول',
    talia: 'تالیا',
    rightel: 'رایتل',
    spadan: 'اسپادان',
    tkc: 'شبکه مستقل تلفن همراه کیش',
    shatel: 'شاتل',
    aptel: 'آپتل',
    azartel: 'آذرتل',
    samantel: 'سامانتل',
    lotustel: 'لوتوس‌تل',
    anarestan: 'انارستان',
};
/**
 * A constant object. Keys are Mobile operator names and values are arrays those keep mobile codes.
 * @type {?}
 */
const MobileCodes = {
    irancell: ['0901', '0902', '0903', '0904', '0905', '0930', '0933', '0935', '0936', '0937', '0938', '0939', '0941'],
    mci: ['0910', '0911', '0912', '0913', '0914', '0915', '0916', '0917', '0918', '0919', '0990', '0991', '0992'],
    talia: ['0932'],
    rightel: ['0920', '0921', '0922'],
    spadan: ['0931'],
    tkc: ['0934'],
    shatel: ['099810', '099811', '099812'],
    aptel: ['099910', '099911', '099913'],
    azartel: ['099914'],
    samantel: ['099996', '099997', '099998', '099999'],
    lotustel: ['09990'],
    anarestan: ['09944']
};
/**
 * This service using for validating phone numbers sold by Iranian Mobile operators.
 *
 * You can get operator name and validation result of a phone number by methods of this service.
 */
class MobilePhoneNumberService {
    /**
     * This method only checks if phoneNumber follows valid pattern. means starting by +98 or 0, then a 9 digit and then 9 digits.
     * This method will not check validity of the phoneNumber code and can accept invalid strings those only locking like phone numbers and
     * in reality are not a valid phone number.
     * @link isValidPhoneNumber
     * @param {?} phoneNumber Digits in this string should be english digits.
     * @return {?}
     */
    isPhoneNumberPatternValid(phoneNumber) {
        /** @type {?} */
        const generalRegex = new RegExp(/^((\+98|0)9\d{9})$/);
        return generalRegex.test(phoneNumber);
    }
    /**
     * Removes +98 from the phoneNumber and replaces it with a 0 character.
     * @param {?} phoneNumber Digits in this string should be english digits.
     * @return {?}
     */
    normalizePhoneNumber(phoneNumber) {
        return phoneNumber.replace('+98', '0');
    }
    /**
     * Checks all codes of all operators in MobileCodes object. IF finds a matched code, returns persian or english name of that operator from
     * operatorsNames enum.
     * @throws InvalidMobileOperatorError if pattern is correct but operator code is not valid. / InvalidMobilePhoneNumberError If pattern is not correct
     * @link MobileCodes / operatorsNames
     * @param {?} phoneNumber Digits in this string should be english digits.
     * @param {?=} nameInEnglish if true, operator name will return in English. if false operator name will return in persian
     * @return {?} operator name in english or persian according to the nameInEnglish parameter
     */
    getPhoneNumberOperator(phoneNumber, nameInEnglish = false) {
        if (!this.isPhoneNumberPatternValid(phoneNumber)) {
            throw new InvalidMobilePhoneNumberError();
        }
        phoneNumber = this.normalizePhoneNumber(phoneNumber);
        for (const operator of Object.keys(MobileCodes)) {
            for (const code of MobileCodes[operator]) {
                if (phoneNumber.indexOf(code) === 0) {
                    return nameInEnglish ? operator : operatorsNames[operator];
                }
            }
        }
        throw new InvalidMobileOperatorError();
    }
    /**
     * @link getPhoneNumberOperator
     * @param {?} phoneNumber Digits in this string should be english digits.
     * @return {?} If phoneNumber follows correct pattern and has valid operator, return true. Otherwise returns false.
     */
    isValidPhoneNumber(phoneNumber) {
        try {
            this.getPhoneNumberOperator(phoneNumber);
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
MobilePhoneNumberService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ MobilePhoneNumberService.ngInjectableDef = ɵɵdefineInjectable({ factory: function MobilePhoneNumberService_Factory() { return new MobilePhoneNumberService(); }, token: MobilePhoneNumberService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * When mobile phone number is not valid this error will throw.
 */
class InvalidNationalCodeError extends Error {
    /**
     * @param {?=} nationalCode
     * @param {...?} params
     */
    constructor(nationalCode = '', ...params) {
        super(...params);
        this.nationalCode = nationalCode;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        // @ts-ignore
        if (Error.captureStackTrace) {
            // @ts-ignore
            Error.captureStackTrace(this, InvalidNationalCodeError);
        }
        this.message = `The national code value (${this.nationalCode}) is not a valid national code.`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * For validating Iranian National code (number), you can use this service in your components or every other places using DI or not.
 */
class NationalCodeService {
    /**
     *
     * [We are using for loop instead of match or split because it has better performance according to this link]{\@link https://stackoverflow.com/a/46312614/5400597}
     * @private
     * @param {?} input
     * @return {?} true if all characters of the `input` are equal and input length is greater than 1. Otherwise returns false.
     */
    _is_repetitive(input) {
        if (input.length < 2) {
            return false;
        }
        /** @type {?} */
        const firstChar = input.charAt(0);
        for (let i = 1; i < input.length; i++) {
            if (input.charAt(i) !== firstChar) {
                return false;
            }
        }
        return true;
    }
    /**
     * This method adds zero character at the beginning of the input until the length of the result reach to 10.
     *
     * This method removes spaces from right and left sides of the input.
     *
     * ATTENTION: This method doesn't any validation about correctness of the input if it has correct length (between 8 and 10).
     * @throws InvalidNationalCodeError when length of the input value is greater than 10.
     * @param {?} nationalCode a number with at most 10 digits or a string with at most 10 character.
     * @return {?} a string with length equal to 10.
     */
    normalize(nationalCode) {
        if (!nationalCode) {
            throw new InvalidNationalCodeError();
        }
        nationalCode = nationalCode.toString();
        nationalCode = nationalCode.trim();
        /** @type {?} */
        const nationalCodeLength = nationalCode.length;
        if (nationalCodeLength > 10 || nationalCodeLength < 8) {
            throw new InvalidNationalCodeError(nationalCode);
        }
        return '0'.repeat(10 - nationalCodeLength) + nationalCode;
    }
    /**
     * This method first normalizes the input using `normalize` method and implicitly checks input length, So you DO NOT NEED to
     * normalize input before, but this will not make any bad effect.
     *
     * [Then checking validation of the input using algorithm described in this link]{\@link http://www.aliarash.com/article/codemeli/codemeli.htm}
     * @param {?} nationalCode
     * @return {?}
     */
    isValid(nationalCode) {
        if (!nationalCode) {
            return false;
        }
        nationalCode = nationalCode.toString();
        if (this._is_repetitive(nationalCode)) {
            return false;
        }
        try {
            nationalCode = this.normalize(nationalCode); // Normalizing the input and checking input length validation implicitly.
        }
        catch (e) {
            return false; // Input length is not in the valid range.
        }
        /** @type {?} */
        let multiplicationResult = 0;
        for (let i = 0; i < 9; i++) {
            multiplicationResult += parseInt(nationalCode.charAt(i), 10) * (10 - i);
        }
        /** @type {?} */
        const reminder = multiplicationResult % 11;
        /** @type {?} */
        const controlNum = parseInt(nationalCode.charAt(9));
        /** @type {?} */
        let desiredControlNum = reminder;
        if (reminder > 1) {
            desiredControlNum = 11 - reminder;
        }
        return desiredControlNum === controlNum;
    }
}
NationalCodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NationalCodeService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NationalCodeService_Factory() { return new NationalCodeService(); }, token: NationalCodeService, providedIn: "root" });

export { EnNumPipe, FaNumPipe, IRCurrencyPipe, JDate, JalaliDateCalculatorService, JalaliDateValidatorService, JdatePipe, MobileCodes, MobilePhoneNumberService, NationalCodePipe, NationalCodeService, NgxPersianModule, PersianLetterDirective, PersianLetterService, PersianNumberService, PersianNumbersDirective, operatorsNames, persianLettersValidator, persianNumbersValidator };
//# sourceMappingURL=ngx-persian.js.map
